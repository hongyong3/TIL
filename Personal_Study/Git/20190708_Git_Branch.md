# 20190708

## Git Branch



여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능



#### 브랜치(branch)란?

* 브랜치란 독립적으로 어떤 작업을 진행하기 위한 개념. 필요에 의해 만들어지는 각각의 브랜치는 다른 브랜치의 영향을 받지 않기 때문에, 여러 작업을 동시에 진행할 수 있음.

* 또한, 이렇게 만들어지는 브랜치는 다른 브랜치와 병합(Merge)함으로써, 작업한 내용을 다시 새로운 하나의 브랜치로 모을 수 있음. 

* 여러 명이서 동시에 작업을 할 때에 다른 사람의 작업에 영향을 주거나 받지 않도록, 먼저 메인 브랜치에서 자신의 작업 전용 브랜치를 만듬. 그리고 각자 작업을 진행한 후, 작업이 끝난 사람은 메인 브랜치에 자신의 브랜치의 변경 사항을 적용. 이렇게 함으로써 다른 사람의 작업에 영향을 받지 않고 독립적으로 특정 작업을 수행하고 그 결과를 하나로 모아 나가게 됨. 이러한 방식으로 작업할 경우 '작업 단위', 즉 브랜치로 그 작업의 기록을 중간 중간에 남기게 되므로 문제가 발생했을 경우 원인이 되는 작업을 찾아내거나 그에 따른 대책을 세우기 쉬워짐.



#### Master 브랜치

* 저장소를 처음 만들면, Git은 바로 'master'라는 이름의 브랜치를 만들어 둠. 이 새로운 저장소에 새로운 파일을 추가 한다거나 추가한 파일의 내용을 변경하여 그 내용을 저장(커밋, commit)하는 것은 모두 'master'라는 이름의 브랜치를 통해 처리할 수 있는 일이 됨.

* 'master'가 아닌 또 다른 새로운 브랜치를 만들어서 선언(체크아웃, checkout)하지 않은 이상, 이 때의 모든 작업은 'master'브랜치에서 이루어 짐.



#### 브랜치 만들기

* Git에서는 작업에 따라 자유롭게 브랜치를 만들 수 있음.



#### 브랜치 종류

##### 통합브랜치(Integration Branch)

* 통합 브랜치란 언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치. 그렇기 때문에 늘 안정적인 상태를 유지하는 것이 중요. 여기서 '안정적인 상태'란 현재 작업 중인 소스코드가 모바일에서 동작하는 어플리케이션을 개발하기 위한 것이라면, '그 어플리케이션의 모든 기능이 정상적으로 동작하는 상태'를 의미.
* 만약 이 어플리케이션에 어떤 문제가 발견되어 그 문제(버그)를 수정한다던지 새로운 기능을 추가해야 한다던지 해야할 때, 바로 '토픽 브랜치(Topic branch)'를 만들 수 있음. 처음에는 보통 통합 브랜치에서 토픽 브랜치를 만들어 냄.
* 일반적으로 저장소를 처음 만들었을 때에 생기는 'master' 브랜치를 통합 브랜치로 사용.



##### 토픽 브랜치(Topic Branch)

* 토픽 브랜치란, 기능 추가나 버그 수정과 같은 단위 작업을 위한 브랜치. 여러 개의 작업을 동시에 진행할 때에는, 그 수만큼 토픽 브랜치를 생성할 수 있음.
* 토픽 브랜치는 보통 통합 브랜치로부터 만들어 내며, 토픽 브랜치에서 특정 작업이 완료되면 다시 통합 브랜치에 병합하는 방식으로 진행. 이러한 토픽 브랜치는 '피처 브랜치(Feature Branch)'라고 부르기도 함.



#### 브랜치 전환하기

* Git에서는 항상 작업할 브랜치를 미리 선택해야함. 처음에 Git을 설치하게 되면 'master'브랜치가 선택됨. 현재 브랜치가 아닌 다른 브랜치에서 작업하고 싶을 때에는, '체크아웃(checkout)'명령어를 실행하여 원하는 브랜치로 전환할 수 있음. 체크아웃을 실행하면, 우선 브랜치 안에 있는 마지막 커밋 내용이 작업 트리에 펼쳐짐. 브랜치가 전환 되었으므로 이 후 실행한 커밋은 전환한 브랜치에 추가됨.



#### HEAD

* 'HEAD'란 현재 사용 중인 브랜치의 선두 부분을 나타내는 이름. 기본적으로는 'master'의 선두 부분을 나타냄. 'HEAD'를 이동하면, 사용하는 브랜치가 변경됨.

* 커밋을 지정할 때, '~(틸트, 물결기호)'와 '^(캐럿, 삽입기호)'을 사용하여 현재 커밋으로부터 특정 커밋의 위치를 가리킬 수 있음. 이 때 자주 사용하는 것이 'HEAD'로서, '~(틸트)'와 숫자를 'HEAD' 뒤에 붙여 몇 세대 앞의 커밋을 가리킬 수 있음. '^(캐럿)'은, 브랜치 병합에서 원본이 여럿 있는 경우 몇 번째 원본인지를 지정할 수 있음.



#### stash

* 커밋하지 않은 변경 내용이나 새롭게 추가한 파일이 인덱스와 작업 트리에 남아 있는 채로 다른 브랜치로 전환(checkout)하면, 그 변경 내용은 기존 브랜치가 아닌 전환된 브랜치에서 커밋할 수 있음.
* 단, 커밋 가능한 변경 내용 중에 전환된 브랜치에서도 한 차례 변경이 되어 있는 경우에는 체크아웃에 실패할 수 있음. 이 경우 이전 브랜치에서 커밋하지 않은 변경 내용을 커밋하거나, stash를 이용해 일시적으로 변경 내용을 다른 곳에 저장하여 충돌을 피하게 한 뒤 체크아웃을 해야 함.
* stash란, 파일의 변경 내용을 일시적으로 기록해두는 영역임. stash를 사용하여 작업트리와 인덱스 내에서 아직 커밋하지 않은 변경을 일시적으로 저장해 둘 수 있음. 이 stash에 저장된 변경 내용은 나중에 다시 불러와 원래의 브랜치나 다른 브랜치에 커밋할 수 있음.



#### 브랜치 통합하기

* 작업이 완료된 토픽 브랜치는 최종적으로 통합 브랜치에 병합됨. 브랜치 통합에는 merge를 사용하는 방법과 'rebase'를 사용하는 방법의 2가지 종류가 있음. 어는 쪽을 사용하느냐에 따라 통합 후의 브랜치 이력이 달라짐.



##### merge

* merge를 사용하면, 여러 개의 브랜치를 하나로 모을 수 있음.

* 예를 들어 'master' 브랜치에서 분기하는 'bugfix'라는 브랜치가 있다고 가정.

  이 'bugfix' 브랜치를 'master' 브랜치로 병합할 때, 'master'브랜치의 상태가 이전부터 변경되어 있지만 않으면 매우 쉽게 병합할 수 있음. 'bugfix' 브랜치의 이력은 'master' 브랜치의 이력을 모두 포함하고 있기 때문에, 'master' 브랜치는 단순히 이동하기만 해도 'bugfix' 브랜치의 내용을 적용할 수 있음. 또한 이 같은 병합은 'fast-forward(빨리 감기) 병합'이라고 부름.

* 하지만 'bugfix' 브랜치를 분기한 이후에 'master' 브랜치에 여러 가지 변경 사항이 적용되는 경우도 잇음. 이 경우에는 'master' 브랜치 내의 변경 내용과 'bugfix' 브랜치 내의 변경 내용을 하나로 통합할 필요가 있음.

* 따라서 양쪽의 변경을 가져온 'merge commit(병합 커밋)'을 실행하게 됨. 병합 완료 후, 통합 브랜치인 'master' 브랜치로 통합된 이력이 아래 그림과 같이 생기게 됨.

![1](https://user-images.githubusercontent.com/45934494/60783367-42814080-a185-11e9-9721-a0fbf4234df0.PNG)

* 병합 실행 시에 'fast-foward 병합'이 가능한 경우라도 'non fast-forward 병합' 옵션을 지정하여 아래 그림과 같이 만들어 낼 수 있음.
* 'non fast-forward 병합'을 실행하면, 브랜치가 그대로 남기 때문에 그 브랜치로 실행한 작업 확인 및 브랜치 관리 면에서 더 유용할 수 있음.



---



##### rebase

![2](https://user-images.githubusercontent.com/45934494/60783789-3302f700-a187-11e9-97ab-ce16051f2d35.PNG)

* 위와 마찬가지로, 'master' 브랜치에서 분기하는 'bugfix' 브랜치가 있다고 가정.
* 우선 'bugfix' 브랜치를 'master' 브랜치에 rebase 하면, 'bugfix' 브랜치의 이력이 'master' 브랜치 뒤로 이동하게 됨. 그 때문에 그림과 같이 이력이 하나의 줄기로 이어짐.
* 이 때 이동하는 커밋 X와 Y 내에 포함되는 내용이 'master'의 커밋된 버전들과 충돌하는 부분이 생길 수 있음. 그 때는 각각의 커밋에서 발생한 충돌 내용을 수정할 필요가 있음.

![3](https://user-images.githubusercontent.com/45934494/60783822-5d54b480-a187-11e9-9003-f3b9a16e6d51.PNG)

* 'rebase'만 하면 아래 그림에서와 같이, 'master'의 위치는 그대로 유지됩니다. 'master' 브랜치의 위치를 변경하기 위해서는 'master' 브랜치에서 'bugfix' 브랜치를 fast-foward(빨리감기) 병합 하면 됨.

![1562561585817](C:\Users\multicampus\AppData\Roaming\Typora\typora-user-images\1562561585817.png)



##### merge && rebase의 차이

* merge와 rebase는 통합 브랜치에 토픽 브랜치를 통합하고자 하는 목적은 같으나, 특징은 다름.



* merge

  > 변경 내용의 이력이 모두 그대로 남아 있기 때문에 이력이 복잡해짐.
  >
  > 통합 브랜치에 토픽 브랜치를 불러올 경우에는 우선 rebase를 한 후 merge



* rebase

  > 이력은 단순해지지만, 원래의 커밋 이력에 변경됨. 정확한 이력을 남겨야 할 필요가 있을 경우에는 사용하면 안됨.
  >
  > 토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우에는 rebase를 사용.