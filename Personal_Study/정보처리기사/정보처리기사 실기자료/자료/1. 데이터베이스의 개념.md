1. 데이터베이스의 개념

1) 정의 : 특정 조직의 업무를 수행하는데 있어서 필요한 상호 관련된 데이터들의 모임

다음과 같은 단어들로 정의가능

\- Integrated Data(통합데이터)

검색의 효율성을 위해 중복을 최소화한 데이터

\- Stored Data(저장 데이터)

컴퓨터가 접근 가능한 저장 매체에 저장된 데이터

\- Operational Data(운영 데이터)

조직의 목표를 위해 존재 가치가 확실하고 반드시 필요한 데이터

\- Shared Data(공유 데이터)

여러 프로그램들이 공동으로 사용하는 데이터



2) 특징(구분만 할줄알면 되겠지)

\- Real Time Accessibility(실시간 접근성)

사용자의 쿼리에 즉시 처리하여 응답

\- Continuous Evolution(계속적인 진화)

항상 최근의 정확한 데이터를 동적으로 유지

\- Concurrent Sharing(동시 공유)

여러 사용자가 동시에 원하는 데이터를 사용가능

\- Content Reference(내용에 의한 참조)

데이터를 참조할 때 내용으로 참조(물리적 주소값으로 하지X)

**- Independence(데이터의 논리적/물리적 독립성)**

-- 논리적 독립성(응용 프로그램과 데이터베이스와의 관계) : 데이터의 논리적 구조 변경하더라도 응용프로그램에 영향을 주지 않는다

-- 물리적 독립성(응용 프로그램과 보조기억장치와의 관계) : 새로운 저장장치의 추가에도 응용 프로그램에는 영향을 주지 않는다



3) Data Language

DB의 구축과 이용을 위해 DBMS와의 통신 수단

\- DDL(Data Definition Language)

\- DML(Data Manipulation Language)

-- 절차적 DML : Oracle의 PL/SQL 생각하면 되

-- 비절차적 DML : SQL

\- DCL(Data Control Language)



4) User의 분류

\- 데이터베이스 관리자; DBA(DataBase Administrator)

데이터베이스를 정의하고 제어하는 사람 또는 그룹

\- 데이터 관리자; DA(Data Administrator)

조직 내에서 데이터에 대한 정의, 체계화, 감독 및 보안 업무

\- 데이터 설계자; DA(Data Architect)

데이터의 구조를 체계적으로 정의하는 사람





\2. DBMS(Database Management System)

기존 파일 시스템의 문제점

\- **데이터 종속성** : 응용프로그램과 데이터파일간의 의존적관계(그니까 응용프로그램바꾸면 데이터도 그에 맞게끔 바껴야되는 문제점)

\- **데이터 중복성** : 데이터의 중복으로 일관성이 없어지고, 동등한 보안 수준과 무결성을 유지하기 힘들다







\3. Schema - DB의 구조와 제약 조건에 관한 전반적인 명세(Specification)

\- 데이터 사전(시스템 카탈로그; 메타 데이터)에 저장

\- 사용자의 관점에 따라 분류

**-- 외부 스키마(서브 스키마)**

사용자나 응용 프로그래머가 각 개인의 입장에서 필요로하는 DB의 논리적 구조를 정의

**-- 개념 스키마(흔히 말하는 스키마)**

개체 간의 관계와 제약조건, DB의 접근 권한, 보안 정책 및 무결성 규정에 관한 명세를 정의

DBA에 의해 작성

**-- 내부 스키마**

DB의 물리적 구조를 정의





\4. 데이터베이스의 설계 - 데이터베이스 스키마를 개발하는 과정이다

**1st) 요구 조건 분석**



**2nd) 개념적 설계**

\- 개념 스키마 모델링

-- 추상화를 통해 개념 스키마를 만드는데 Entity와 Relationship을 사용하는 추상화를 ER Model이라고 함

\- 트랜잭션 모델링



**3rd) 논리적 설계**

\- 컴퓨터가 이해하고 처리할 수 있는 특정 DBMS가 지원가능한 논리적 데이터 구 조로 변환

\- 즉, 논리 스키마의 설계과정이다

\- 관계형 DBMS의 경우에는 ER Model을 Relation Schema로 변환

-- 더 좋은 Relation Schema를 위해 정규화(Normalization) 과정을 수행(데이터의 중복과 종속성을 방지하기 위해)

\- 트랜잭션의 전체적인 골격을 개발하고 인터페이스를 정의한다



**4th) 물리적 설계**

\- 물리 스키마를 설계하는 것이 목적

\- DB 파일에 대한 저장 구조와 접근 경로를 결정



**5th) 데이터베이스 구현**

\- 해당 DBMS의 DDL을 통해 구축







\5. ER Model(Entity-Relationship Model)

**- 대표적인 개념적 데이터 모델로써 Entity, Relationship, Attribute을 도형화 하여 표현(ERD; ER Diagram)**



\- 현실 세계를 표현한다고 생각하면 되!



**- Entity**

-- Entity Occurrence 또는 Entity Instance (Such as Record in Table) : 하나의 Entity를 이르는 용어

-- Entity Type : Entity Occurrence들의 공통의 Attribute를 가지는 Entity Class

--- ERD에서 직사각형으로 표현함



**- Relationship**

-- Relationship Type : ERD에서 마름모로 표현

-- Degree(차수) : Relationship에 참여하는 Entity Type의 개수

-- Mapping Cardinality(대응 카디널리티) : Relationship에 참여하는 Entity Occurrence의 개수

--- 1 : 1 관계

--- 1 : N 관계

--- N : M 관계

-- ISA 관계 : Entity가 서로 구별되는 하위 Entity로 나누어 질 수 있다

--- disjoint : 상위 Entity가 하나의 하위 Entity체에만 포함

--- overlapping : 상위 Entity가 여러 개의 하위 Entity에 포함될수 있다

--- total : 상위 Entity Occurrence가 하위 Entity에 속한다

--- partial : 상위 Entity Occurrence가 하위 Entity에 속하지 않는다



**- Attribute(타원으로 표현)**

-- Domain : Attribute가 가질 수 있는 값의 집합

-- 모든 Entity Type은 Primary Key에 속하는 Attribute를 가진다

--- Primary Key는 타원 안에 가로로 선하나 더 그으면되





\6. Relationship Data Model

**- 대표적인 논리적 데이터 모델로써 Table 또는 Relation의 구조로 표현**



\- 용어 정리

-- **Relation** : 이차원의 테이블로써 데이터를 표현하는 수단

--- **Relation Schema** : Relation의 이름, 각 Attribute에 대해 정의한 것

--- **Relation Instance** : Relation에 들어있는 Tuple들의 집합

-- **Attribute** : Relation의 Columns

-- **Tuple** : Relation의 Rows

-- **Domain** : 하나의 Attribute가 가질 수 있는 같은 Type의 값들의 집합

-- **Degree** : Relation의 Attribute의 개수

-- **Cardinality** : Relation의 Tuple의 개수

-- 식별 관계(Identifying)

Relation A와 B에서 A의 Primary Key가 B의 Foreign Key면서 Primary Key

Relation B의 존재여부가 Relation A의 존재 여부에 의존적인 경우

ERD에서 실선으로 표시

-- 비식별 관계(Non-identifying)

Relation A와 B에서 A의 Primary Key가 B의 Foreign Key면서 Primary Key는 X

ERD에서 점선으로 표시



**- 논리적 설계에서 개념적 데이터 모델인 ER Model을 Relationship Data Model로 변환(Mapping Rule이라고도 한다)**

1st) Entity A, B를 독립적인 Relation A, B으로 표기

2nd) Relationship의 종류에 따라 다음의 과정을 수행

i) 1 : 1

Relation A나 Relation B의 Primary Key를 다른 Relation의 Foreign Key로 추가

ii) 1 : N

Relation A의 Primary Key를 Relation B의 Foreign Key로 추가

iii) N : M

Relation A와 B의 Primary Key를 별도의 Relation(Intersection Relation 또는 Intersection Entity; 교차~~)으로 표현

즉, 두개의 1 : N 로 변환시켜서 표현한다고 생각하면된다

※ ISA관계에서

방법 1) 상/하위 Entity 따로 표기

1st) Entity들을 독립적인 Relation으로 표기

2nd) 상위 Entity의 Primary Key를 하위 Entity에 Primary Key로 추가한다

방법 2) 상위 Entity를 하위 Entity들에 포함

1st) 하위 Entity들만 Relation으로 표기

2nd) 각 Relation의 Primary Key로 상위 Entity의 Primary Key를 추가한다







\7. Key

**Super Key**

Attribute의 집합으로 구성된 Key / 유일성 O / 최소성 X(하나 빼도 유일성이 유지된다는 말)



**Candidate Key**

Tuple을 유일하게 식별하기 위해 사용되는 Attribute의 부분집합 / 유일성 O / 최소성 O



**Primary Key**

Candidate Key 中, 선정된 Key / 중복된 값 X / Not Null / 유일성 O / 최소성 O



**Alternate Key**

Candidate Key 中, Primary Key를 뺀 나머지 Key들 / 유일성 O / 최소성 O



**Foreign Key**

다른 Relation의 Primary Key를 참조하는 Attribute(들) / 중복된 값 X / Not Null / 유일성 O / 최소성 O







\8. 무결성(Integrity)

DB에 저장된 데이터 값과 실제 값이 일치하는 정확성

**- 무결성 제약 조건** : 정확하지 않은 데이터가 DB 내에 저장되는 것을 방지하기 위한 제약 조건

-- NULL 무결성 : 특정 Attribute값이 Not Null

-- 고유(Unique) 무결성 : 특정 Attribute에 대해 각 Tuple들이 서로 다른 값

-- Domain 무결성 : 특정 Attribute값이 Domain에 속한 값

-- Key 무결성 : 하나의 Relation엔 적어도 하나의 Key가 있어야 한다

-- 관계(Relationship) 무결성 : Relation에서 Tuple의 삽입 가능 여부, 서로 다른 Relation의 Tuple들 사이의 관계에 대한 적절성 여부

-- 참조(Referential) 무결성 : Foreign Key는 Null이거나 참조 Relation의 Primary Key와 동일

-- 개체(Entity) 무결성 : Primary Key를 구성하는 Attribute는 Not Null

※ 개체무결성이랑 NULL 무결성이랑 헷갈려







\9. 관계대수(Relational Algebra)

관계형 DB에서 원하는 정보와 그 정보를 어떻게 유도하는지 기술하는 절차적 언어

\- 순수 관계 연산자

**SELECT**

조건만족하는 Tuple의 부분집합으로 Realtion을 만듬 / σ Condition (Relation) ; ex) σ국어>80(성적)

**PROJECT**

주어진 Attribute 값만을 추출하여 Relation을 만듬 / π Attibute (Relation) ; ex) π이름,국어(성적)

**JOIN**

공통 Attribute를 중심으로 2개의 Relation을 하나로 합쳐서 새로운 Relation을 만듬

Relation ▷◁Constraint Relation ; ex) 성적 ▷◁이름=이름 학적부

Cartensian Product 연산한후 Select 연산 수행한 것과 동일하다

​					-- Cartensian Product : 걍 Relation 두개 조합한거

Constraint을 θ로 일반화할 수 있는 JOIN을 θ-Join(Theta JOIN)이라고도 한다

Natural JOIN : JOIN 조건이 =일 때 동일한 속성이 2번 나타나므로 중복을 제거해서 같은 속성은 한번만 표기하는 JOIN

**DIVISION**

Relation [ Attribute ÷ Attribute ] Relation

ex) 구입자 [ 구입품 코드 ÷ 생산품 코드 ] 생산품

​					구입자에서 생산품의 생산품 코드의 값들과 연관 있는 Tuple만 추출하되 구입품 코드 Attribute는 제외한다



\- 일반 집합 연산자 : 수학에서 사용되는 집합 연산자를 Relation 연산에서도 사용이 가능

**UNION(합집합)** : ∪ : 결과에서 중복되는 Tuple은 제거

**INTERSECTION(교집합)** : ∩

**DIFFERENCE(차집합)** : －

**CARTENSIAN PRODUCT(교차곱)** : × : Relation에 존재하는 모든 Tuple끼리 결합





\10. 관계해석(Relational Calculus)

원하는 정보가 무엇이라는 것만 정의하는 비절차적 언어로써 Tuple 관계해석과 Domain 관계해석이 있다

관계대수로 표현한걸 관계해석으로 표현할 수 있다

질의어로 표현한다







\11. SQL(Structured Query Language)

1) DDL(Data Define Language) - **CREATE / ALTER / DROP**

DDL로 정의된 내용은 Metadata가 되며 System Catalog에 저장된다



\- CREATE SCHEMA 스키마이름 AUTHORIZATION 사용자ID;

\- CREATE DOMAIN 도메인이름 데이터타입

[DEFAULT 기본값] [CONSTRAINT [제약조건명] CHECK (범위값)]; -- CHECK 포함해서 총 4개 가능해 자세한건 생략

\- CREATE TABLE 테이블이름

(속성명 데이터타입 [NOT NULL], [, 속성명 데이터타입 [NOT NULL], ...]

[, PRIMARY KEY(기본키속성명, ...)]

[, FOREIGN KEY(외래키속성명, ...) REFERENCES 참조테이블 (참조테이블의기본키)

​					[ON DELETE {NO ACTION | CASCADE | SET NULL | SET DEFAULT}]

​					[ON UPDATE {NO ACTION | CASCADE | SET NULL | SET DEFAULT}]

]

[, CONSTRAINT [제약조건명] CHECK (범위값)] -- CHECK 포함해서 총 4개 가능해 자세한건 생략

);

\- CREATE VIEW 뷰명 (속성명 [, 속성명, ...]) AS SELECT문

\- CRAETE [UNIQUE] INDEX 인덱스명 -- UNIQUE는 중복제거

ON 테이블명(속성명 {ASC | DESC} [, 속성명 {ASC | DESC}) -- Default Sort : ASC

[CLUSTER] -- Tuple을 그룹으로 지정하기 위한거라는데 모르겠다

\- CRAETE TRIGGER 트리거명 [{AFTER | BEFORE}] [{INSERT | DELETE | UPDATE}] ON 테이블명

REFERENCING [{NEW | OLD}] TABLE AS 테이블명 -- NEW는 새로 추가/변경될때 | OLD는 변경되었을때 적용

FOR EACH ROW

WHEN 조건식 -- 예를들어 WHEN new_table.학년='1'

내용 -- 예를들어 BEGIN SET new_table.학년='신입생'; END;



\- ALTER TABLE 테이블명 ADD 속성명 데이터타입 [DEFAULT '기본값'];

\- ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];

\- ALTER TABLE 테이블명 DROP 속성명 [CASCADE];



\- DROP {SCHEMA | DOMAIN | TABLE | VIEW | INDEX | TRIGGER | CONSTRAINT} 이름명 [{CASCADE | RESTRICT}]



2) DML(Data Manipulation Language) - **SELECT / JOIN**

**- SELECT [{ALL | DISTINCT | DISTINCTROW}] [테이블명.]속성명[ AS 별칭][, [테이블명.]속성명[ AS 별칭], ...]**

FROM 테이블명[, 테이블명, ...]

[WHERE 조건] -- 비교연산자 / 논리연산자 / LIKE

[GROUP BY 속성명[, 속성명, ...]

[HAVING 조건] -- 그룹 함수에 대한 조건 ; 그룹함수(AVG(속성명),MAX(속성명),MIN(속성명),SUM(속성명),COUNT(속성명))

[ORDER BY 속성명 {ASC | DESC}[, 속성명 {ASC | DESC}]]; -- 기본값은 ASC

※ GROUP BY로 묶인 속성이나 그룹함수와 일반 속성은 함께 사용 불가.

예) 'SELECT 부서,이름,생일,AVG(기본급) AS 평균 GROUP BY 부서'에섯 이름,생일은 사용불가

※ 그룹함수와 GROUP BY, HAVING절 예시

SELECT 부서, COUNT(*) AS 사원수 FROM 사원 WHERE 기본급>=100

​					GROUP BY 부서 HAVING COUNT(*)>=2;

사원 테이블에서 기본급이 100이상이고 사원수가 2명이상인 부서의 부서명과 사원수

※ 하위 질의(SELECT IN SELECT)

※ 복수 테이블 검색(FROM 절에 복수의 테이블 / 속성에서 구분은 테이블명.속성명)

※ UNION(합집합) : SELECT문 UNION SELECT문(중복은 제거되서 출력)



**- JOIN**

-- INNER JOIN

--- EQUI JOIN : 공통 속성끼리 =(equal) 비교에 의해 같은 값을 가지는 행을 연결

기본 형식 : SELECT ... WHERE 테이블명1.속성명 = 테이블명2.속성명; -- WHERE절을 JOIN조건이라 한다.

NATURAL JOIN : SELECT ... FROM 테이블명1 NATURAL JOIN 테이블명2 -- 중복제거

JOIN~USING절 : SELECT ... FROM 테이블명1 JOIN 테이블명2 USING(속성명); -- 공통 속성이 같은 이름

--- NON-EQUI JOIN : JOIN조건에 = 조건이 아닌걸 사용(>, <, <>, 등)

기본 형식 : SELECT ... WHERE (조건);

​							예) WHERE 학생.성적 BETWEEN 성적등급.최저 AND 성적등급.최고;

-- OUTER JOIN : JOIN조건에 만족하지 않는 튜플도 결과로 출력하기 위한 방법

--- LEFT OUTER JOIN : 우측항 릴레이션과 맞지 않는 좌측항 릴레이션의 튜플에 NULL값을 대입(결국 좌측 릴레이션은 모두 출력)

SELECT ... FROM 테이블명1 LEFT OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명

SELECT ... WHERE 테이블명1.속성명 = 테이블명2.속성명(+);

--- RIGHT OUTER JOIN : LEFT OUTER JOIN과 반대(결과적으로 우측 릴레이션은 모두 출력)

SELECT ... FROM 테이블명1 RIGHT OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명

SELECT ... WHERE 테이블명1.속성명(+) = 테이블명2.속성명;

--- FULL OUTER JOIN : JOIN 조건의 양쪽 릴레이션의 튜플들 모두 출력

SELECT ... FROM 테이블명1 FULL OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명

-- SELF JOIN : 같은 테이블에 2개의 속성을 연결해서 EQUI JOIN



3) DML - **SELCT / INSERT / DELETE / UPDATE**

\- INSERT INTO 테이블명[(속성명1[, 속성명2, ...])]

VALUES (값1[, 값2, ...]);

※ VALUES (값1[, 값2, ...]) 대신에 SELECT문 가능

\- DELETE FROM 테이블명 WHERE 조건;

\- UPDATE 테이블명 SET 속성명=값[, 속성명=값, ...] WHERE 조건;



4) DCL(Data Control Language) : 데이터의 보안, 무결성, 회복, 병행제어 등 / DBA가 데이터 관리하는게 목적

\- COMMIT : 트랙잭션의 모든 변경내용을 영구적으로 DB에 반영

\- ROLLLBACK : 트랙잭션의 모든 변경내용을 취소하고 DB를 이전 상태로 되돌리기

\- GRANT : DB User에게 권한을 부여

i) GRANT { DBA / RESOURCE / CONNECT } TO 사용자ID [IDENTIFIED BY 암호];

ii) GRANT 권한리스트 ON 개체 TO 사용자 [WITH GRANT OPTION];

-- 권한리스트 : ALL / SELECT / INSERT / DELETE / UPDATE / ALTER / 등

\- REVOKE : 권한 취소

i) REVOKE { DBA / RESOURCE / CONNECT } FROM 사용자ID

ii) REVOKE [GRANT OPTION FOR] 권한리스트 ON 개체 FROM 사용자 [CASECADE];

-- GRANT OPTION FOR는 WITH GRANT OPTION해제





\12. VIEW

\- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야 삽입 / 삭제 / 갱신이 가능

\- 정의된 뷰는 다른 뷰를 정의하는데 기초가 될 수 있다.

\- 둘 이상의 테이블에서 유도된 뷰는 변경X

\- DISTINCT / GROUP BY / HAVING을 사용해 만든 뷰는 변경X



CRAETE VIEW 뷰명[(속성명[, 속성명, ...])]

AS SLECT절

[WITH CHECK OPTION]; -- 뷰에 대한 갱신/삽입 연산시, 뷰의 정의 조건 위배하면 실행 거부(SELECT절의 WHERE절의 참거짓)

예) CREATE VIEW DB_학생 AS SELECT 학번,이름 FROM 학생 WHERE 학과="컴공" WITH CHECK OPTION;



DROP VIEW 뷰명 { RESTRICT | CASCADE };

-- RESTRICT : 해당 뷰를 다른 곳에서 참조시 제거 취소

-- CASCADE : 해당 뷰 를 다른 곳에서 참조시 참조하는 다른 뷰나 제약 조건까지 모두 제거





\13. Embeded SQL : 응용 P/G에서 SQL문을 내포해서 실행되도록 호스트 P/G에 삽입한 SQL

C/C++(변수선언/SQL실행시에 EXEC SQL을 어두에 붙인다)

i) Cursor 사용 X

EXEC SQL BEGIN DECLARE SECTION;

변수를 선언한다.

EXEC SQL END DECLARE SECTION;

로직을 적는다(변수 사용시엔, 변수앞에 :(콜론)붙여야되)

EXEC SQL

SELECT SNAME, DEPT INTO :SNAME, :DEPT -- SNAME,DEPT를 SNAME,DEPT라는 변수에 저장.

​					FROM STUDENT WHERE SNO=:SNO; -- DB의 SNO 속성값과 SNO라는 변수를 비교

ii) Cursor 사용

EXEC SQL BEGIN DECLARE SECTION;

변수를 선언한다.

EXEC SQL END DECLARE SECTION;



EXEC SQL DECLARE person CURSOR FOR

SELECT SNAME, DEPT FROM STUDENT WHERE SNO=:SNO;



EXEC SQL OPEN person;



EXEC SQL FETCH person [INTO 변수]; -- 변수에 읽은값저장하고 커서이동



EXEC SQL CLOSE person; -- 커서 닫기



※ JAVA에서는 #SQL{<SQL문>}





\14. Stored Procedure : PL/SQL처럼 특정한 SQL문을 저장해놓고 가져다 씀

CREATE [OR REPLACE] PROCEDURE 프로시저명({ IN | OUT }파라미터[, { IN | OUT }파라미터, ...])

[DECLEARE 변수명 자료형 -- 변수선언]

BEGIN

PROCEDURE BODY

END;





\15. 이상(Anomaly) : 테이블의 일부 속성들이 종속으로인해 데이터 중복이 발생하고 이로 인해 테이블 조작 시 문제 발생하는 현상

**- 삽입 이상(Insert Anomaly)** : 데이터 삽입할 때 의도와 상관없이 원치 않은 값들로 인해 삽입할 수 없게 되는 현상

**- 삭제 이상(Delete Anomaly)** : 한 튜플을 삭제할 때 의도와 상관없는 값들도 삭제되는, 연쇄 삭제가 발생하는 현상

**- 갱신 이상(Update Anomaly)** : 튜플에 있는 속성 값을 갱신할 때 일부 튜플 정보만 갱신되어 정보에 불일치성이 생기는 현상



※ 원인 : 여러가지 종류의 사실들(값들)을 하나의 릴레이션에 표현하기 때문

※ 해결 : 속성들 간의 종속성을 분석해서, 하나의 종속성은 하나의 릴레이션에 표현되도록 분해. 이를 정규화라고한다.





\16. 함수적 종속(Functional Dependency)

어떤 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라 할 때

속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때

'Y는 X에 함수적 종속' 또는 'X가 Y를 함수적으로 결정한다'라고 하며 X→Y로 표기한다.

X→Y의 관계에서 X를 결정자(Determinant), Y를 종속자(Dependent)

※ 연관이라는 개념을 결정짓는다라는 개념으로 보면될듯 : X가 결정되면 Y도 결정된다.

**- 완전 함수적 종속(Full Functional Dependency)**

X→Y이면서도 X의 임의의 진부분집합인 Z와는 종속관계가 없는 속성

**- 부분 함수적 종속(Partial Functional Dependency)**

X→Y이면서도 X의 임의의 진부분집합인 Z와도 Z→Y인 속성







\17. 정규화(Nomarlization)

테이블의 속성들의 종속적인 관계를 이용해 테이블을 무손실 분해하는 과정으로

가능한 한 중복을 제거하여 삽입 / 삭제 / 갱신 이상의 발생 가능성을 줄이는 것이다.



**비정규 릴레이션**

↓ 도메인이 원자값

**제 1정규형(1NF; First Nomal Form)** : 테이블에 속한 모든 속성의 도메인이 원자 값(Atomic Value)임

↓ 부분적 함수 종속 제거

**제 2정규형(2NF)** : 기본키가 아닌 모든 속성이, 기본키에 대하여 완전 함수적 종속을 만족

↓ 이행적 함수적 종속(Transitive Functional Dependency) 제거

​					-- A→B이고 B→C일때, A→C를 만족하는 관계

**제 3정규형(3NF)** : 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음

↓ 결정자가 후보키가 아닌 함수종속 제거

**BCNF(Boyce-Codd Normal Form)** 모든 결정자가 후보키

↓ 다치종속(MVD; Multi-Valued Dependency) 제거

​					-- 테이블 R(A,B,C)에서 (A,B)→(C)도 성립하고 (A)→(C)도 성립할때 다치 종속

**제 4정규형(4NF)** : 테이블 R의 다치 종속(MVD) A→→B가 존재할 경우, R의 모든 속성이 A에 함수적 종속

↓ 조인종속 제거

**제 5정규형(5NF or PJNF)** : 테이블 R의 모든 조인 종속(JD)이 R의 후보키를 통해서만 성립

-- 조인 종속(JD) : 테이블 R과 R의 프로젝션들을 모두 조인한 결과가 동일

-- 여기서는 R의 프로젝션으로 R의 후보키가 온다고보면됨



※ 첫 글자 따서 : 도부이결다조





\18. 시스템 카탈로그(System Catalog; 데이터 사전(Data Dictionary)이라고도한다)

DBA의 도구로써 DB에 저장되어 있는 모든 데이터 개체들에 대한 정의나 명세에 대한 정보가 수록되어있는 테이블

DBMS에 의해 생성되고 유지되며 사용자가 SQL문으로 시스템 카탈로그의 수정은 안된다. 사용자와 DBMS의 접근이 가능하다

시스템 카탈로그에 저장된 내용을 메타 데이터(Metadata)라고 한다.

구성 요소(MS-SQL Server 2005)

\- SYSOBJECTS

\- SYSCOLUMNS

\- SYSINDEXES

\- SYSVIEWS

\- SYSUSERS

\- SYSPROTECTS





\19. 인덱스(Index) : 튜플에 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조

\- 기본 인덱스 : 기본키를 위한 인덱스. 관계형 DBMS에서는 모든 기본키에 자동적으로 기본 인덱스를 생성

\- 보조 인덱스 : 기본 인덱스가 아닌 나머지

\- 클러스터(Cluster) 인덱스 : 인덱스 테이블의 키 값 순서와 튜플의 물리적 순서를 동일하게 유지하는 인덱스

※ 행 이주(Row Migration)

-- 인덱스 테이블에서 튜플의 값을 자료형 보다 크게 넣으면 해당 튜플은 뒤로 밀려나게된다.

-- 예를 들어 자료형이 varchar인 경우 생각해보면되.

\- 종류

-- m-원 검색트리(m-Way Search Tree ; Multiway Tree of order m)

이진 검색 트리을 수정한 것으로, 한 노드가 최대 m-1개의 키 값과 최대 m개의 서브 노드를 가진다.

각 노드 안에는 포인터와 키 값들이 존재한다. 포인터의 최대 개수는 m개이고 키 값의 최대 개수는 m-1이다.

각 노드 안의 키 값들은 오름차순으로 차례대로 저장된다.

좋은 성능을 위해서는 최대한 m을 크게 해야하며 균형에 가까워야 한다. 균형이 잡힌 상태를 B-Tree라고 한다.



-- B 트리(B Tree)

인덱스를 구성하는 방법으로 많이 사용되는 균형잡힌 m-원 검색트리이다.

루트는 단말 노드가 아닐 때, 적어도 2개의 서브트리를 가진다.

루트도 아니고 단말 노드도 아니라면 최소 m/2, 최대 m개의 서브노드를 가진다.

모든 단말 노드들은 같은 높이를 가진다.

-- B* 트리(B* Tree)

B-트리의 빈번한 노드 분할을 줄이는 목적으로 제시되었다.

각 노드가 최소한 2/3가 채워진 상태여야 한다.

한 노드가 가득차고 인접 노드가 모두 가득찰 때까지 분할을 지연시킨다.

-- B+ 트리(B+ Tree)

B-트리의 순차적인 순회 작업에 대한 해결책으로 제시되었다.

인덱스 세트와 순차 세트로 구분 된다.

인덱스 세트(Index Set) : 단말 노드가 아닌 노드들로 구성

​					키 값을 단말 노드에 있는 키 값으로 직접 찾아가는데 사용

순차 세트(Sequence Set) : 단말 노드로만 구성

​					모든 키 값을 단말 노드에 나열된다. 인덱스 세트의 키 값들도 다시 한번 나열된다.

​					순차적으로 Linked list를 구성하고 있어서 순차적 처리가 가능하다.





\20. 트랜잭션(Transaction) : DB에서 하나의 놀리적 기능을 수행하기 위한 일련의 연산 집합. 작업의 논리적 단위

\- COMMIT : 하나의 트랜잭션이 정상적으로 종료될 경우 수행되는 연산

\- ROLLBACK : 하나의 트랜잭션이 비정상적으로 종료될 경우 수행되는 연산

\- 특징(ACID)

-- 원자성(Atomicity) : 트랜잭션의 연산은 DB에 모두 반영되든지 전혀 반영되지 않던지 둘 중 하나

-- 일관성(Consistency) : 시스템이 가지고 있는 고정적인 요소는 트랜잭션의 연산이 끝나도 동일

-- 독립성(Isolation) : 한 트랜잭션이 데이터를 갱신하는 동안 다른 트랜잭션들은 접근하지 못한다.

-- 영속성(Durability) : 트랜잭션이 완료된 후에는 시스템 오류가 발생해도 트랜잭션에 의해 변경된 내용은 보존됨



\- 상태

-- 활동(Active)

-- 실패(Failed)

-- 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 ROLLBACK 연산을 수행한 상태

-- 부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 수행하고 COMMIT 연산 하기 전

-- 완료(Committed)





\21. 회복(Recovery) : 트랜잭션 실행 도중 장애가 발생해 DB각 손상되었을 경우 다시 복구하는 작업

\- 장애의 유형

-- 실행 장애(Action Failure) : 사용자의 실수 / 무결성 규칙 위반 등으로 질의 실행이 실패

-- 트랜잭션 장애(Transaction Failure) : 비정상적인 상황으로 인해 트랜잭션 실행이 중지

-- 시스템 장애(System Failure) : DB에는 손상을 입히지 않으나 H/W의 오동작, 정전 등에 의해 모든 트랜잭션이 실행 불가

-- 미디어 장애(Media Failure) : 저장장치의 손상 / 오동작으로 DB의 일부 또는 전부가 물리적으로 손상되는 현상

\- 회복 관리기(Recovery Manager)

-- Log / Memory Dump 등을 이용항 회복을 수행하는 DBMS의 핵심 구성요소

-- 트랜잭션이 성공적으로 완료 되지 않았으면, Log를 이용해 트랜잭션이 DB의 모든 변화를 취소(Undo)해서 회복

-- 트랜잭션이 성공적으로 완료 되었으나 디스크에 반영되지 않았을 경우, Log를 이용해 재작업(Redo)를 수행

--- Commit만 하지 못했다는 의미; 부분 완료(Partially Committed)라고 한다

※ Commit을 수행 했고 장애가 생기면 Redo / 아니면 Undo

\- 회복 기법

-- 연기 갱신(Differed Update) 기법

--- 트랜잭션이 성공적으로 종료될 때까지 DB에 대한 실질적인 갱신 연기

--- 실행되는 동안 변경된 내용은 Log에 보관 / 부분완료 시점에 Log로 DB에 반영

--- 애초에 DB에 적용을 안하기에 장애가 생겨도 Redo 작업만 하면된다.

-- 즉각 갱신(Immediate Update) 기법

--- 트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료되기 전이라도 바로 DB에 반영

--- 장애를 대비해 모든 변경내용 Log에 저장

--- Redo와 Undo 모두 수행

-- 그림자 페이지(Shadow Paging) 기법

--- 갱신 이전의 DB를 페이지(Page)단위로 구성해 카피해놓고, 실제 페이지를 대상으로 트랜잭션에 대한 변경작업 반영

--- 장애생겨서 Rollback할 때, 해당 페이지만 복구

--- Log와 Redo, Undo 모두 필요 없다.

-- 검사점(Check Point) 기법

--- Redo / Undo를 위해 Log 전체를 조사하는 걸 피하기 위한 기법

--- 트랜잭션 실행중 주기적으로 변경 내용이나 상황과 검사점을 같이 Log에 저장한다.

--- 장애 발생시, 전체 Log 조회가 아니라 가장 최근 검사점으로 회복 작업 수행

-- 미디어 회복(Media Recovery) 기법

--- DB의 내용을 주기적으로 안전한 스토리지에 덤프

--- 장애 발생시, 가장 최근의 덤프를 디스크에 적재하고, Log를 이용해 최근의 트랜잭션에 대해 Redo





\21. 병행 제어(Concurrency Control) 참고 : http://flyingdcat4.tistory.com/m/post/72

\- 동시에 다수의 트랜잭션을 수행할때, DB의일관성 파괴않도록 트랜잭션 끼리 상호작용을 제어 하는 기술

\- 병행성 : 다수의 트랜잭션들이 동시에 인터리빙(Interleaving)하게 실행되는 것

\- 목적

-- DB의 공유를 최대화

-- 시스템 활용도 최대화

-- 사용자에 대한 응답 시간 최소화

-- 단위 시간당 트랜잭션 처리 건수 최대화

-- DB의 일관성 유지

\- 병행 제어 없으면 생기는 문제점

-- 갱신 분실(Lost Update) : 다수의 트랜잭션이 같은 데이터를 공유, 갱신할 때 갱신 결과의 일부가 분실됨

-- 모순성(Inconsistency; 불일치성) : 다수의 사용자가 동시에 같은 데이터를 갱신할 때, DB 내의 데이터들이 불일치

-- 연쇄 복귀(Cascading Rollback) : 병행 수행되던 트랜잭션들 중 하나가 Rollback하는 경우, 다른 트랜잭션도 Rollback

\- 잠금(Lock) : DB관리 방법. 하나의 트랜잭션이 사용하는 데이터에 다른 트랜잭션이 접근 못하게 하는 것

-- 트랜잭션들은 어떤 데이터에 접근하기 전에 잠금을 요청하여 허락받아야한다.

-- 데이터 갱신 과정 : 잠금(Lock) → 실행(Excute) → 해제(Unlock)

-- 잠금 단위

--- 병행 제어에서 한 번에 잠금할 수 있는 단위로 DB, 테이블, 레코드, 필드 등이 사용될 수 있다.

--- 단위가 커지면 Locking Overhead는 감소하지만 공유성은 낮아진다.

--- 단위가 작아지만 Locking Overhead는 증가하지만 공유성은 높아진다.

-- 교착 상태(Dead Lock)

-- 공유 잠금(Shared-Lock) : 다른 트랜잭션은 읽기만 가능

-- 배타 잠금(Exclusive-Lock) : 다른 트랜잭셔은 읽기/쓰기 불가능

\- 병행 제어 기법의 종류

-- 2-단계 잠금 규약(Two-Phase Lock Porotocol) 기법

--- 트랜잭션 스케쥴(Transaction Schedule)의 직렬성을 보장하는 대표적인 잠금 기법

​					※ 트랜잭션 스케줄(Transaction Schedule) : 트랜잭션들이 인터리빙하게 실행될때 그 순서.

​					※ 직렬 스케줄 : 트랜잭션 사이에 인터리빙이 없다.

--- 모든 트랜잭션들은 잠금과 잠금해제를 다음과 같이 2단계로 수행한다.

---- 확장(Growing) 단계 : 트랜잭션이 잠금만 가능하고 해제는 불가능한 단계

---- 축소(Shrinking) 단계 : 트랜잭션이 잠금 해제만 가능하고 잠금은 불가능한 단계

--- 스케줄의 직렬성을 보장한다는 장점은 있지만 교착 상태는 예방할 수 없다는 단점

-- 타임 스탬프 순서(Time Stamp Ordering) 기법

--- 타임 스탬프 : 시스템이 각 트랜잭션을 실행할 때 부여하는 값(트랜잭션이 발생할때의 시스템 시간 값)

--- 트랜잭션 스케줄의 결과와 직렬 스케줄의 결과가 동일함을 보장하는 기법

--- 직렬성 순서를 결정하기 위해, 트랜잭션 간의 실행 순서를 미리 결정하는 기법으로 가장 보편적인 방법

--- 트랜잭션을 실행하기전에 타임 스탬프를 부여하고, 그 순서에 따라 트랜잭션을 수행한다

--- 교착 상태가 발생하지 않는다.



\22. 보안(Security)

\- 목표

-- 정보 보호 / 정보 인증(악의적 수정과 허위 정보 저장 방지) / 사용자 인증



\- 보안 기법

-- SQL 이용한 권한 부여 기법

--- 뷰(View)를 이용하는 방법

--- DCL을 이용해 권한 부여와 취소

-- 암호화 기법

--- 개인키 암호화(Private Key Encryption) 기법 : DES

--- 공개키 암호화(Public Key Encryption) 기법 : RSA





\23. 튜닝(Tuning)

\- DB의 환경 등을 조정해 DBMS의 성능을 향상시키는 작업

\- DBMS의 높은 작업 처리량과 짧은 응답 시간을 갖도록 하는 것이 중요

\- 목표

-- DB에 접근하는 SQL문 실행시, 디스크 블록에 대한 접근 횟수 최소화

-- 디스크 블록에서 한번 읽어온 데이터는 가능한 한 메모리 영역에 보관하여, 신속한 재사용(캐시(Cache) 용량의 확보)

-- 모든 SQL문은 공유가 가능하도록, 작성 규칙을 준수하여 작성

-- 다수의 사용자가 자원을 안정적으로 사용하게끔 잠금 기능을 최소화 한다.



\- 튜닝의 단계

-- 비즈니스 규칙(Business Rule) 튜닝

--- 시스템 설계와 구현에 대한 부정확한 분석과 부적절한 비즈니스 규칙

-- 데이터 설계(Data Design) 튜닝

--- 구현된 어플리케이션이 필요한 데이터가 무엇인지 정확하게 파악

--- 데이터 간의 관계와 속성을 명확히하고 정보의 구조화 작업을 수행

-- 응용 프로그램 설계(Application Degin) 튜닝

--- 튜닝을 필요로 하는 대상 프로그램을 선정

-- 데이터베이스의 논리적 구조(Logical Structure) 튜닝

--- 부하가 예상되는 질의와 갱신을 고려해서 스키마를 작성

-- 데이터베이스 접근 방식(Access Method) 튜닝

--- SQL의 장점과 응용프로그램의 작업 처리를 최대화 하기 위해 DBMS의 기능을 충분히 활용한다.

-- 접근 경로(Access Path) 튜닝

--- 효과적인 데이터 접근을 위해 B-트리 인덱스 / 비트맵 인덱스 / 역방향 인덱스 등의 사용을 고려

--- 인덱스의 추가 및 삭제와 설계의 개선도 고려

-- 메모리 관리(Memory Management) 튜닝

--- 메모리 자원을 효율적 할당하고 캐시의 성능을 개선, SQL문의 파싱 작업을 감소시킨다.

-- 물리적 구조(Physical Structure) 및 입/출력(Input/Output) 튜닝

--- 접근 비용을 최소화 하기위해 데이터 블럭 운영을 고려

--- 디스크 간의 데이터를 분산해서 디스크의 입/출력 경합을 감소시킨다

-- 자원의 경합(Competition) 튜닝

--- 공유 풀(Shared Pool), 잠금(Lock) 등의 경합 형태를 감소시키기 위한 노력 수행

-- H/W 시스템에 특화된 부분의 튜닝

--- DB는 사용되는 H/W 시스템 종류와 특성에 따라 성능의 차이가 나므로 이에 맞게 튜닝한다

\- 인덱스 튜닝(접근 경로에 대한 튜닝; 쉽고 효율이 높아서 많이 사용됨)

-- 인덱스의 종류

--- B-트리 인덱스

---- 일반적으로 사용되는 인덱싱 방식

---- 데이터 양에 상관없이 모든 데이터 인덱스 탐색 시간이 동일

--- 비트맵 인덱스

---- 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용

---- 분포도가 좋은 컬럼에 적합하다. Bit로 구성되기에 효율적인 논리 연산 기능

---- 저장 공간이 작다

--- 역방향 인덱스

---- 인덱스 컬럼의 데이터를 역으로 변환하여 인덱스 키로 사용하는 방법

---- B-트리 인덱스에서 발생할 수 있는 불균형 문제를 해결

---- 데이터의 분포도가 좋아져 검색 성능이 좋다.

**--- 클러스터드 인덱스(Clustered Index)**

**---- 인덱스 키의 순서에 따라 데이터가 정렬되어 있는 방식**

**---- 데이터가 정렬되어 있기에 인덱스를 검색안해도 데이터를 빠르게 찾을 수 있다**

**---- 데이터 삽입/삭제 발생 시 데이터를 재정렬해야 한다.**

**---- 한 개의 릴레이션에 하나의 인덱스만 생성가능**

**--- 넌클러스터드 인덱스(Non-Clustered Index)**

**---- 인덱스 키만 정렬되어 있고, 데이터는 정렬되지 않는 방식**

**---- 데이터 검색위해, 인덱스를 검색해야 하기에 클러스터드 인덱스에 비해 검색 속도 떨어진다.**

**---- 한 개의 릴레이션에 여러 개의 인덱스 생성가능**

-- 인덱스 선정 기준

--- 분포도(선택성)가 좋은 컬럼은 단독으로 인덱스를 생성

--- 데이터의 변경이 적은 컬럼에 인덱스를 생성

--- 인덱스들이 자주 조합될때는 결합 인덱스(Concatenate Index)를 생성

---- 결합 인덱스의 컬럼 순서는 데이터의 분포도(수치상 낮은거)가 좋은 컬럼을 선행컬럼으로

---- 분포도(선택성)가 좋다? : 같은 키 값을 가지는 튜플의 수가 적다.; 키 종류가 다양할 수록 분포도가 좋다고보면되

-- 인덱스를 사용하지 못하는 경우

--- 인덱스 키 생성 시 NULL 값은 인덱스 대상에 포함되지 않아서, IS NULL과 IS NOT NULL을 사용하면 인덱스 사용 불가

--- <>, !=, NOT 등의 부정 연산자는 다수의 데이터를 검색하므로 인덱스를 이용 불가

--- LIKE '%A'와 같은 경우에는, 처음 부터 다 검색하게 된다.

--- 인덱스 컬럼에 함수나 수식을 사용하면 인덱스 키값이 변형되어 인덱스로 사용 불가





\24. 객체 지향 데이터베이스(ODB; Object-oriented Database)

\- 객체 지향 데이터베이스의 구성

-- 객체와 객체 식별자(OID; Object IDentifier)

-- 속성(Attribute)과 메소드(Method)

-- 클래스(Class)와 인스턴스(Insttance)

-- 상속(Inheritance)

-- 오버로딩(Overloading)과 오버라이딩(Overriding)

\- 객체 관계 데이터베이스(ORDB; Object Relational Database)

-- 관계형 데이터베이스에 객체 지향 데이터베이스의 개념을 추가한 데이터베이스

-- 특징

--- 객체 관계 데이터베이스를 위한 데이터 언어 표준으로 ISO에서 제시한 SQL3

--- 확장 가능 데이터 타입 / 사용자 정의 데이터 타입 / 사용자 정의 함수 / 등을 지원

---- 텍스트파일이나 그래픽 파일 같이 대용량의 데이터 저장을 위해 LOB(Large OBject) 타입이 있다

​					----- 가변 길이 문자 스트링(CLOB) / 가변길이 이진 스트링(BLOB)







\25. 고급 데이터베이스

\- 분산 데이터베이스(Distributed Database)

-- 논리적으로 같은 시스템에 속하지만, 물리적으로는 분산되어있는 데이터베이스

-- 분산 데이터베이스 시스템의 구성요소

--- 분산 처리기 : 지리적으로 분산되어있는 컴퓨터 시스템, 자체 처리 능력을 가진다.

--- 분산 데이터베이스 : 지리적으로 분산되어있는 데이터베이스

--- 통신 네트워크 : 분산 처리기들을 통신망으로 연결해 하나의 시스템처럼 작동할 수 있는 네트워크

-- 목표

--- 위치 투명성(Location Transparency) : 접근하려는 DB의 실제 위치를 알 필요없다.

--- 중복 투명성(Replication Transparency) : 동일한 데이터가 여러 곳에 중복되어도 하나의 데이터만 존재하는 것처럼 사용

--- 병행 투명성(Concurrency Transparency) : 다수의 트랜잭션들이 동시에 수행되어도 서로 영향을 X

--- 장애 투명성(Failure Transparency) : 각종 장애에도 불구하고 트랜잭션은 정확하게 수행된다.



\- 멀티미디어 데이터베이스(Multimedia Database)

-- 텍스트/그래픽/정지화상/동영상/음성 등이 복합적으로 구성된 데이터베이스



\- 주기억장치 데이터베이스(Main Memory Database)

-- 데이터베이스 전체를 주기억장치에 상주시킨 후, 데이터베이스 연산을 수행하는 시스템 ; 디스크 I/O가 발생하지 X



\- 데이터 웨어하우스(Data Warehouse)

-- 다량의 데이터를 효과적으로 분석하여 정보화 하고, 이를 계층의 사용자가 효율적으로 사용하도록 한 데이터베이스

-- 다양한 원본 DB로부터 정제되어 추출된 데이터만을 저장하고 필요한 인덱스를 생성

-- 재빠르고 정확한 의사결정을 도와준다.

\- 데이터 마트(Data Mart)

-- 전사적으로 구축된 데이터 웨어하우스로부터, 특정 주제나 부서 중심으로 구성된 단일 주제의 데이터 웨어하우스

\- 데이터 마이닝(Data Mining)

-- 데이터 웨어하우스에 저장된 데이터 집합에서 사용자의 요구에 따라 유용하고 가능성 있는 정보를 발견하기 위한 기법

-- 기법 종류

--- 연관

--- 연속

--- 분류

--- 클러스터링

--- 특성화

--- 패턴분석

--- 경향 분석



\- OLAP(Online Analytical Processing)

-- 다차원으로 이루어진 데이터로부터, 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식

-- 데이터 웨어하우스, 데이터 마트 같은 시스템과 상홍 연관되는 시스템

-- 데이터 웨어하우스의 데이터를 전략적인 정보로 변환시키는 역할

-- 중간 매개체 없이 이용자들이 직접 컴퓨터를 이용해 데이터에 접근하는데 있어서 필수적인 시스템

-- OLAP 연산

--- Roll-up : 더 요약된 정보보기

--- Drill-down : 더 구체적인 정보보기

--- Pivoting : 보고서의 행/열/페이지 차원을 바꾸어 보는 기능

--- Slicing/Dicing : 다차원 데이터 항목들을 다양한 각도에서 조회하고 자유롭게 비교

-- OLAP 종류

--- ROLAP(Relational-OLAP) : 관계형 데이터베이스와 관계형 질의어를 사용하여 다차원 데이터를 저장하고 분석

--- MOLAP(Multi-dimension OLAP)

---- 다차원 데이터를 저장하기 위해 특수한 구조의 다차원 데이터베이스를 사용한다

---- 검색 속도를 위해 큐브 캐시(Cube Cache)라고 하는 주기억장치 속에 데이터 큐브를 저장한다.

​					----- 데이터 큐브(Data Cube) ; 데이터가 여러 차원으로 모델링 되는 것으로 차원과 사실로 정의된다.

------ 차원(Dimension)은 한 조직이 그것에 대하여 기록하기 원하는 시각이나 개체를 의미

--- HOLAP(Hybrid OLAP)

---- ROLAP과 MOLAP의 특성을 모두 가지고 있다.

---- 빠른 검색을 필요할때는 요약을 메모리에 저장하고 다른건 관계형 데이터베이스에 저장

\- OLTP(Online Transaction Processing)

-- 온라인 업무 처리 형태의 하나. 네트워크 상에서 다수의 유저가 DB의 데이터를 갱신/검색하는 등의 트랜잭션을 처리하는 방식

-- OLTP 시스템은 일반적으로 빠른 응답 시간을 요구 하며, 개개의 레코드를 효율적으로 조회하고 수정할 수 있도록 정규화 되어있다.

★ OLAP와 OLTP의 비교

-- 데이터의 구조        OLAP(복잡) OLTP(단순)

-- 데이터의 갱신        OLAP(순간적/동적) OLTP(주기적/동적)

-- 응답  시간           OLAP(2초이내) OLTP(수 초~몇 분)

-- 데이터 범위          OLAP(과거 30일~90일) OLTP(과거 5년~10년)

-- 데이터 성격          OLAP(정규/핵심업무데이터/변경어렵다) OLTP(비정규/읽기전용/변경용이)

-- 데이터 크기          OLAP(수 GB) OLTP(수 TB)

-- 데이터의 내용        OLAP(상세 데이터) OLTP(기록 보관된 요약/계산 데이터)

-- 데이터의 사용법      OLAP(고도로 구조화된 연속 처리) OLTP(고도로 비구조화된 분석처리)



\- ODBC(Open Database Connectivity)

-- 프로그램과 데이터베이스의 종류에 관계없이 자유롭게 사용할 수 있도록 MS에서만든 API

-- 구조상 데이터베이스 바로위에 ODBC가 위치한다

-- 구조

--- Application : 프로그램; ODBC API를 이용해 데이터베이스에 접근함

--- Driver Manager : Application과 ODBC Driver 간의 통신을 관리하는 라이브러리

--- DSN(Domain Service Name) : 서버에 연결할때 필요한 드라이버와 데이터베이스 정보를 저장

--- ODBC Driver : ODBC API가 지원하는 함수를 구현하는 라이브러리

--- Database



출처: 

https://kit2013.tistory.com/204

 [정윤상이다.]