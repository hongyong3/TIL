# 20191217

## DataBase

### DataBase의 개념



#### DataBase란?

- 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합.
- 자료항목의 중복을 없애고 자료를 구조화하여 저장함으로써 자료 검색과 갱신의 효율을 높임.





#### DataBase의 정의

- **통합 데이터(Integrated Data)**

  > 검색의 효율성을 위해 `중복이 최소화 된 데이터`의 모임.

- **저장 데이터(Stored Data)**

  > 컴퓨터가 접근 가능한 `저장 매체에 저장된 데이터`.

- **운영 데이터(Operational Data)**

  > 조직의 목적을 위해 존재 가치가 확실하고 `반드시 필요한 데이터`.

- **공유 데이터(Shared Data)**

  > 여러 응용 프로그램들이 `공동으로 사용하는 데이터`.





#### DataBase의 특징

* **실시간 접근성(Real Time Accessibility)**

  > 사용자의 질의에 대하여 `즉시 처리하여 응답`하는 특징.

* **계속적인 진화(Continuous Evolution)**

  > 삽입, 삭제, 갱신을 통하여 `항상 최근의 정확한 데이터를 유지`하는 특징.

* **동시 공유(Concurrent Sharing)**

  > 여러 사용자가 `동시에 원하는 데이터를 공유`할 수 있는 특징.

* **내용에 의한 참조(Content Reference)**

  > 데이터베이스에 있는 데이터를 `주소가 아닌 내용에 따라 참조`하는 특징.

* **데이터의 논리적, 물리적 독립성(Independence)**

  > 논리적 독립성 : 데이터의 논리적 구조를 변경시키더라도, 응용 프로그램은 변경되지 않는 특징.
  >
  > 물리적 독립성 : 새로운 물리적 구조를 도입하더라도, 응용 프로그램에는 영향을 주지 않는 특징.





#### DataBase 언어

* 데이터베이스를 구축하고 이용하기 위한 통신 수단.



* **DDL**(Data **Definition** Language : 데이터 **정의**어)

  >DB의 구조, 데이터 형식, 접근 방식 등 DB의 구축과 변경 목적으로 사용하는 언어.
  >
  >DDL 컴파일러가 컴파일 한 후 데이터 사전에 저장.
  >
  >
  >
  >DDL의 기능
  >
  >▶ 데이터베이스의 논리적, 물리적 구조를 정의 및 변경.
  >
  >▶ 스키마(Schema)에 사용되는 제약 조건을 정의.
  >
  >▶ 데이터의 물리적 순서를 규정.



* **DML**(Data **Manipulation** Language : 데이터 **조작**어)

  > 데이터 처리를 위한 응용 프로그램과 데이터베이스 관리 시스템 간의 인터페이스를 위한 언어.
  >
  > 데이터의 검색, 삽입, 삭제, 갱신 연산 등을 포함한 집합.



* **DCL**(Data **Control** Language : 데이터 **제어**어)

  > `보안 및 권한 제어, 무결성, 회복, 병행 제어를 위한 언어`.
  >
  > 병행제어 : 여러 사용자가 동시에 데이터베이스를 공유할 수 있도록 한다.





#### DataBase 사용자

* 데이터베이스 관리자(DBA : DataBase Administrator)

* 데이터 관리자(Data Administrator)

  > 데이터에 대한 정의, 체계화, 감독 및 보안 업무 담당.
  >
  > 데이터 관리 총괄 및 정보 활용에 대한 계획 수립 및 통제 수행.

* 데이터 설계자(Data Architect)

  > 데이터의 구조를 체계적으로 정의하는 자.
  >
  > 데이터 모델을 생성.

* 응용 프로그래머(Application Programmer)

* 일반 사용자(End User)





---

### 데이터베이스 관리 시스템(DBMS; DataBase Management System)



#### DBMS란?

* 사용자와 데이터베이스 사이에서 데이터베이스의 관리를 도와주는 **소프트웨어**.
* 종속성과 중복성의 문제를 해결하기 위한 시스템으로, 모든 응용프로그램이 DB를 공유할 수 있도록 함.





#### DBMS의 필수 기능

* **정의 기능**(Definition Facility) : 구조와 `제약조건` 등을 명시하는 기능 제공.
* **조작 기능**(Manipulation Facility) : 데이터 처리를 위한 `삽입, 삭제, 갱신, 검색`을 명시하는 기능 제공.
* **제어 기능**(Control Facility) : `무결성, 보안 및 권한 검사, 병행 제어` 등을 명시하는 기능 제공.





#### DBMS의 장단점

* 장점

  > 독립성이 보장.
  >
  > 중복을 피할 수 있음.
  >
  > 공동으로 이용할 수 있음.
  >
  > 통합하여 관리가 가능.
  >
  > 일관성을 유지할 수 있음.
  >
  > 표준화 할 수 있음.
  >
  > 무결성을 유지할 수 있음.
  >
  > 보안을 유지할 수 있음.
  >
  > 실시간 처리가 가능.
  >
  > 최신의 데이터를 유지할 수 있음.



* 단점

  > 대용량 디스크의 집중적인 접근으로 인한 과부하 발생.
  >
  > 전산화 비용이 증가.
  >
  > 데이터의 백업과 복구가 어려움.
  >
  > 시스템이 복잡해짐.





---

# 20191218

## DataBase

### Schema(스키마)의 개념



#### Schema란?

* 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언러로 정의한 구조.
* 데이터베이스의 `구조와 제약 조건`에 관한 전반적인 명세(Specification).
* 외부 스키마, 개념 스키마, 내부 스키마로 나뉨.





#### Schema의 특징

* 데이터의 구조적 특성을 의미.
* `데이터 사전`(Data Dictionary)에 저장.

* 현실 세계의 한 부분을 표현한 것으로, 특정 데이터 모델을 이용해 만들어짐.
* 시간에 따라 불변.
* 데이터의 논리적 단위에 명칭을 부여하고 그 의미를 기술함.





#### Schema의 3계층

* **외부 스키마**

  > 외부 사용자의 관점.
  >
  > 서브 스키마(Sub Schema)라고도 부름.
  >
  > 하나의 DataBase에 대해서 여러 개가 존재할 수 있음.
  >
  > 동일한 DataBase에 대해 서로 다른 관점을 정의할 수 있도록 허용.



* **개념 스키마**

  > 개체간의 관계와 제약조건을 명시함.
  >
  > 접근 권한, 보안 정책, 무결성 규정에 관한 명세.
  >
  > 단순히 스키마라고 하면 개념 스키마를 의미.
  >
  > 조직의 관점.
  >
  > DBA에 의해서 작성됨.
  >
  > 오직 하나만 존재.



* **내부 스키마**

  > 물리적 저장장치의 관점.
  >
  > DataBase의 물리적 구조를 정의.
  >
  > 시스템 프로그래머, 시스템 설계자가 보는 관점.





#### 데이터 사전(메타 데이터)

* 모든 데이터 개체들에 대한 정보를 유지・관리하는 시스템.
* `시스템 카달로그`라고도 함.
* `데이터에 관한 데이터`, 메타 데이터라고도 함.

*   MARC(MAchine Readable Catalog)

  > 목록 레코드를 식별하여 축적・유통할 수 있도록 코드화한 메타 데이터.

* DC(Dublin Core)

  > 네트워크 환경에서 각종 전자 정보를 기술하는 메타 데이터.

* ONIX(ONline Information eXchange)

  > 유통에 관한 통계와 체계적인 정보를 취급함으로써 정상적인 유통 및 관리를 위한 메타 데이터.

* MODS(Metadata Object Description Schema)

  > 디지털 도서관의 범용 서지 정보 표준 메타 데이터로서 MARC, DC, ONIX 등을 절충하여 `상호 운용성`과 `정밀성`을 모두 만족시킴.





---

# 20191219

## DataBase

### DataBase Design



#### DataBase의 설계의 개념

* DataBase의 구조.

  즉, DataBase 스키마를 개발하는 과정.





#### DataBase 설계 순서

**요구 조건 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 데이터베이스 구현**



* 요구 조건 분석(Requirement Analysis)

  > 요구 조건을 수집하고 분석하여 공식적인 `요구 조건 명세(Requirement Specification)를 작성`.

* 개념적 설계(Conceptual Design)

  > `개념 스키마 모델링`과 트랜잭션 모델링을 병행하여 수행.
  >
  > 집단화와 일반화가 있음.

* 논리적 설계(Logical Design)

  > 현실 세계의 데이터를 컴퓨터가 처리할 수 있는 논리적 데이터 구조로 변환시킴.
  >
  > `논리 스키마`를 설계.
  >
  > `ER도형을 정형적인 규칙에 따라 릴레이션 스키마로 변환.`
  >
  > `정규화` 과정을 수행함.

* 물리적 설계(Physical Design)

  > 저장 구조와 접근 경로를 결정.
  >
  > `물리 스키마`를 설계.
  >
  > 인덱싱, 클러스터링, 해싱 등의 설계가 포함.
  >
  > 응답시간, 접근 경로에 대한 효율성, 트랜잭션 처리도 등을 고려해야함.

* 데이터베이스 구현(DataBase Implementation)

  > `DDL`을 사용하여 데이터베이스를 생성.





---

# 20191220

## DataBase

### Relational Data Model



#### 관계형 데이터 구조

##### `릴레이션`

* 데이터를 원자 값(Atomic Value)으로 갖는 이차원의 테이블.
* 논리적 구조를 나타냄.
* `릴레이션 스키마(구조)`와 `릴레이션 인스턴스(실제 값)`로 구성.
* 한 속성 안에서 `원자 값들이 집합을 도메인`이라고 함.





#### ER모델

##### 관계형 데이터 모델 변환

* ER모델을 릴레이션 스키마로 변환(`Mapping Rule`)
* 개체 -> 개체 릴레이션
* 관계 -> 관계 릴레이션
* 속성 -> 컬럼(Column)
* `식별자` -> `기본키`
* `관계` -> `외래키`
* `N : M`의 관계일 경우에는 `교차 릴레이션(Intersection Relation)을 생성.





#### `식별 관계・비식별 관계`

* 식별 관계(Identifying)

  > A 개체의 기본키가 B 개체의 `외래키이면서 기본키`인 관계.
  >
  > `실선`으로 표시함.

* 비식별 관계(Non-Identifying)

  > A 개체의 기본키가 B 개체의 `비기본키 영역에서 외래키`가 되는 관계.
  >
  > `점선`으로 표시함.





---

# 20191220

## DataBase

### Key의 개념 및 종류



#### 슈퍼키(Super Key)

* 속성들의 집합으로 구성된 키.
* `유일성은 만족`하나, `최소성은 만족하지 못함`.





#### 후보키(Candidate Key)

* `유일성과 최소성을 만족`하는 기본키를 제외한 키.





#### 기본키(Primary Key)

* 후보키 중에서 특별히 선정된 키.
* `NULL값과 중복값을 가질 수 없음`.
* 유일성과 최소성을 가짐.
* `튜플을 식별하기 위해 반드시 필요한 키`.





#### 대체키(Alternate Key)

* 기본키를 제외한 나머지 후보키.





#### 외래키(Foreign Key)

* 다른 릴레이션의 기본키를 `참조`하는 속성.
* `관계`를 표현할 때 사용.





---

# 20191220

## DataBase

### 무결성(Integrity)



#### 무결성의 개념

* 현실 세계의 값과 Data가 일치하는 `정확성`을 의미.
* 무결성 제약 조건(Constraint)는 DataBase에 정확성을 해치는 값이 오지 않게 하기 위한 조건.





#### 무결성의 종류

* NULL 무결성

  > 특정 속성 값이 NULL이 될 수 없음.

* 고유 무결성

  > 각 튜플이 갖는 속성 값은 서로 달라야함.

* 도메인 무결성

  > 특정 속성 값이 그 속성이 정의된 도메인에 속해야 함.

* 키 무결성

  > 하나의 리레이션에 적어도 한개의 키는 있어야함.

* 관계 무결성

  > 임의 튜플의 삽입 가능 여부 또는 튜플들 간의 관계에 대한 적절성 여부에 대한 규정.

* 참조 무결성

  > 외래키의 값은 NULL이거나 참조되는 기본키 값과 동일해야 함.

* 개체 무결성

  > 기본키를 구성하는 어떤 속성도 NULL이 될 수 없음.





---

# 20191222

## DataBase

### 관계대수(Relational Algebra)



#### 관계대수의 개념

* 원하는 정보와 그 정보를 어떻게 유도하는지 기술하는 `절차적 언어`.
*   SELECT, PROJECT, JOIN, DIVISION, UNION, CARTESIAN PRODUCT 등이 있음.





#### 순수 관계 연산자

* `SELECT`

  > 조건을 만족하는 튜플을 모아 새로운 릴레이션을 만듦.
  >
  > 행에 해당하는 튜플을 구함(수평 연산).
  >
  > 기호는 시그마(σ).
  >
  > AND(∧), OR(∨), NOT(￢)을 사용할 수 있음.



* `PROJECT`

  > 제시된 속성값만을 추출하여 새로운 릴레이션을 만듦.
  >
  > 열에 해당하는 속성을 구함(수직 연산).
  >
  > 기호는 파이(π).



* `JOIN`

  > 공통 속성을 중심으로 2개의 릴레이션을 합쳐 새로운 릴레이션을 만듦.
  >
  > `CARTESIAN PRODUCT를 수행한 후 SELECT를 수행한 것과 동일`.
  >
  > 기호는 ▷◁.
  >
  > 비교연산자를 θ로 일반화 한 것을 `세타 조인`이라고 함.
  >
  > θ가 '='일 경우 `동일 조인(Equi JOIN)`이라 함.
  >
  > 중복된 속성을 제거하고 1번만 나타내는 조인을 `자연 조인(Natural JOIN)`이라 함.





#### 일반 집합 연산자

* UNION, DIFFERENCE, INTERSECTION을 처리하기 위해서는 합병조건을 만족해야 함.
* 합병조건 : 두 속성의 수가 같고, 속성별 도메인이 같을 것.





#### 관계해석(Relation Calculus)

* `원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성`을 가짐.





---

# 20191223

## DataBase

### 시스템 카탈로그(System Catalog)



#### 시스템 카탈로그의 개념

* `모든 데이터 개체들에 대한 정늬나 명세`.
* DDL의 결과로 구성되는 정보들.
* `데이터 사전`이라고도 함.





#### 시스템 카탈로그의 내용

* 릴레이션 관련 정보

  > 이름
  >
  > 저장된 파일 이름과 파일 구조
  >
  > 속성들에 대한 속성 이름과 도메인
  >
  > 정의된 인덱스의 이름
  >
  > 정의된 무결성 제약 조건



* 인덱스 관련 정보

  > 이름
  >
  > 구조
  >
  > 키에 대한 정보



* 뷰 관련 정보

  > 이름
  >
  > 정의
  >
  > 소유자



* 통계 관련 정보

  > 릴레이션 카디널리티
  >
  > 인덱스 카디널리티
  >
  > 인덱스의 높이 : 각 트리 인덱스에 대한 레벨
  >
  > 인덱스의 범위 : 각 인덱스에 대한 최소, 최대 키 값





#### 시스템 카탈로그의 특징

* SQL문을 이용하여 내용을 검색해 볼 수 있음.
* DBMS에 의해 생성되고 유지.
* 자동으로 갱신.
* 사용자가 직접 갱신할 수 없음.





---

# 20191224

## DataBase

### 인덱스(Index)



#### 인덱스의 개념

* 튜플에 빨리 접근하기 위한 <키, 포인터> 쌍.
* 인덱스가 없으면 모든 데이터를 다 뒤지는 TABLE SCAN이 발생.





#### m - 원 검색 트리(m-Way Search Tree)

* 한 노드가 1개의 키 값과 2개의 서브 노드를 갖는 이진 검색 트리를 일반화 한 트리.
* 한 노드가 최대 m - 1개의 키 값과 최대 m개의 서브 노드를 갖음.
* 이진 검색 트리보다 분기율이 향상되어 트리 깊이가 낮아져 특정 노드에 대한 검색 시간이 감소.
* 키의 삽입, 삭제 시 트리의 균형을 유지하기 위하여 복잡한 연산이 수반되어야 한다는 단점이 있음.





#### B - 트리

* 인덱스를 구성하는 방법으로 많이 사용되는 균형된 m-원 검색 트리.

* 키 값과 레코드를 가리키는 포인터들이 트리 노드에 오름차순으로 저장.

* 키의 삽입과 삭제 시 노드의 분열과 합병이 발생할 수 있음.

* 차수가 m인 B - 트리의 특징.

  > 모든 노드는 최대 m개의 서브 노드를 가짐.
  >
  > 루트(Root) 노드와 단말 노드를 제외한 모든 노드는 최소 m / 2개, 최대 m개의 서브 노드를 가짐.
  >
  > 루트 노드는 단말 노드가 아닌 이상 적어도 2개의 서브 노드를 가짐.
  >
  > 단말 노드가 아닌 노드에 있는 키 값의 수는 그 노드의 서브 노드 수보다 하나 적음.
  >
  > 모든 단말 노드는 같은 레벨에 있음. (루트로부터 같은 거리에 있음).
  >
  > 한 노드 안에 있는 키 값들은 오름차순을 유지.





#### B *- 트리

* B-트리는 B-트리의 문제점인 빈번한 노드의 분할을 줄이는 목적으로 제시된 B-트리의 변형.

* B-트리에서는 각 노드가 가능한 한 최소 2 / 3가 채워지도/록 한 것이 특징.

* 차수가 m인 B-트리의 특징.

  > 루트 노드를 제외한 모든 노드는 최소 (2m - 2) / 3개, 최대 m개의 서브 노드를 가짐.
  >
  > 루트 노드는 그 자체가 단말 노드가 아닌 경우 적어도 2개의 서브 노드를 가짐.
  >
  > 단말 노드가 아닌 노드에 있는 키 값의 수는 그 노드의 서브 노드 수 보다 하나 적음.
  >
  > 모든 단말 노드는 같은 레벨에 있음(루트로부터 같은 거리에 있음). 
  >
  > 한 노드 안에 있는 키 값들은 오름차순을 유지.





#### B +- 트리

* B +- 트리는 B - 트리의 변형으로 단말 노드가 아닌 노드로 구성된 인덱스 세트(Index Set)와 단말 노드로만 구성된 순차 세트로 구분.

* 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로만 제공되며, 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴.

* 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차 처리가 가능.

* B +- 트리에서의 직접 접근에는 인덱스 세트가 사용되고, 순차 접근에는 순차 세트가 사용.

* 차수가 m인 B +- 트리의 특징

  > 루트 노드와 단말 노드를 제외한 모든 노드는 최소 m / 2개, 최대 m개의 서브 노드를 가짐.
  >
  > 루트 노드는 0 또는 2에서 m개 사이의 서브 노드를 가짐.
  >
  > 단말 노드가 아닌 노드에 있는 키 값의 수는 그 노드의 서브 노드 수보다 하나 적음.
  >
  > 모든 단말 노드는 같은 레벨에 있음(루트로부터 같은 거리에 있음).
  >
  > 한 노드 안에 있는 키 값들은 오름차순을 유지.
  >
  > 순차 세트 내의 단말 노드들은 모두 링크로 연결되어 있음.