# 20190209

## Python

### 클래스(Class)



#### 8) 클래스 변수와 인스턴스 변수

6.4절에서는 클래스의 네임스페이스와 인스턴스의 네임스페이스, 그리고 그 둘 사이의 관계에 대해 배웠습니다. 이번 절에서는 초보자들이 많이 어려워하는 개념 중 하나인 클래스 변수(class variable)와 인스턴스 변수(instance variable)에 대해 살펴보겠습니다.

다음은 은행 계좌를 클래스로 표현한 것입니다. Account 클래스에는 생성자와 소멸자가 있습니다. 생성자(`__init__`)가 클래스의 인스턴스가 생성될 때 자동으로 호출되는 함수라면 소멸자(`__del__`)는 클래스의 인스턴스가 소멸될 때 자동으로 호출되는 함수입니다.



```python
>>> class Account:
        num_accounts = 0
        def __init__(self, name):
                self.name = name
                Account.num_accounts += 1
        def __del__(self):
                Account.num_accounts -= 1
```



Account 클래스에는 num_accounts와 self.name이라는 두 종류의 변수가 있습니다. num_accounts처럼 클래스 내부에 선언된 변수를 클래스 변수라고 하며, self.name과 같이 self가 붙어 있는 변수를 인스턴스 변수라고 합니다. 클래스 변수는 Account 클래스의 네임스페이스에 위치하며, self.name과 같은 인스턴스 변수는 인스턴스의 네임스페이스에 위치하게 됩니다.

그렇다면 언제 클래스 변수를 사용해야 하고 언제 인스턴스 변수를 사용해야 할까요? 이에 대한 답은 간단한 코드를 작성해보면서 천천히 설명해 드리겠습니다. 여러분이 은행에 가서 계좌를 개설하면 새로운 계좌가 하나 개설됩니다. 이러한 상황을 파이썬으로 표현하면 다음과 같이 Account 클래스의 인스턴스를 생성하는 것에 해당합니다.



```python
>>> kim = Account("kim")
>>> lee = Account("lee")
```



생성된 kim과 lee 인스턴스에 계좌 소유자 정보가 제대로 저장돼 있는지 확인해 봅시다. 각 계좌에 대한 소유자 정보는 인스턴스 변수인 name이 바인딩하고 있습니다.



```python
>>> kim.name
'kim'
>>> lee.name
'lee'
```



그렇다면 지금까지 은행에서 개설된 계좌는 총 몇 개일까요? 네, 정답은 'kim'과 'lee'에게 하나씩 개설됐기 때문에 두 개겠죠? kim 인스턴스나 lee 인스턴스를 통해 num_accounts라는 이름에 접근하면 총계좌개설개수가2개로나오는것을알수있습니다.



```python
>>> kim.num_accounts
2
>>> lee.num_accounts
2
```



물론 지금까지 공부를 잘 해오신 분들은 kim.num_accounts에서 먼저 인스턴스의 네임스페이스에서 num_accounts를 찾았지만 해당 이름이 없어서 클래스의 네임스페이스로 이동한 후 다시 해당 이름을 찾았고 그 값이 반환된 것임을 아실 것입니다.

이처럼 여러 인스턴스 간에 서로 공유해야 하는 값은 클래스 변수를 통해 바인딩해야 합니다. 왜냐하면 파이썬은 인스턴스의 네임스페이스에 없는 이름은 클래스의 네임스페이스에서 찾아보기 때문에 이러한 특성을 이용하면 클래스 변수가 모든 인스턴스에 공유될 수 있기 때문입니다. 참고로 클래스 변수에 접근할 때 아래와 같이 클래스 이름을 사용할 수도 있습니다.



```python
>>> Account.num_accounts
2
```



지금까지 작성한 코드에서 클래스 변수와 인스턴스 변수를 그림으로 나타내면 그림 6.15와 같습니다. 앞으로 클래스 변수와 인스턴스 변수가 헛갈릴 때마다 이 그림을 기억하기 바랍니다.



![img](https://wikidocs.net/images/page/1744/6.15.png)

​								**그림 6.15 클래스 변수와 인스턴스 변수**



---



#### 9) 클래스 상속

상속이란 사람이 사망함에 따라 사망자의 재산 및 신분상의 지위에 대한 포괄적인 승계를 의미합니다. 드라마에서 보면 부모님으로부터 많은 재산을 상속받은 사람들을 종종 볼 수 있지요? 상속하는 사람 입장은 잘 모르겠지만 상속자들은 분명 상속받지 않은 경우보다 대부분 좋은 경우가 많을 것입니다. 특히 많은 재산을 상속받는 경우라면 더욱 좋겠지요?

프로그래밍 책에서 갑자기 상속 이야기를 한 이유는 객체지향 프로그래밍을 지원하는 프로그래밍 언어는 클래스에서 상속 기능을 지원하기 때문입니다. 자식이 부모님으로부터 재산 등을 상속받는 것처럼 다른 클래스에 이미 구현된 메서드나 속성을 상속한 클래스에서는 그러한 메서드나 속성을 그대로 사용할 수 있게됩니다.

클래스의 상속을 또 다른 관점에서 생각해보면 클래스를 상속한다는 것은 부모 클래스의 능력을 그대로 전달받는 것을 의미합니다. 인간으로 치면 부모로부터 유전형질을 물려받아 부모의 능력을 그대로 물려받는 것과 비슷합니다.

일단 노래를 잘 부르는 부모 클래스가 있다고 생각해 봅시다. 이를 파이썬으로 표현하면 다음과 같이 노래를 부르는 메서드가 포함된 클래스를 정의할 수 있습니다.



```python
>>> class Parent:
        def can_sing(self):
                print("Sing a song")

```



Parent 클래스를 정의했으니 클래스의 인스턴스를 생성해 보겠습니다. 그리고 노래를 정말 할 수 있는지 메서드를 호출해 확인해 보겠습니다.



```python
>>> father = Parent()
>>> father.can_sing()
Sing a song
```



이번에는 노래를 잘 부르는 Parent 클래스로부터 상속받은 운이 좋은 자식 클래스를 정의해 봅시다. 클래스의 이름은 LuckyChild라고 하겠습니다. 클래스를 정의할 때 다른 클래스로부터 상속받고자 한다면 새로 정의할 클래스 이름 다음에 괄호를 사용해 상속받고자 하는 클래스의 이름을 지정하면 됩니다. LuckyChild 클래스는 상속받기 전까지는 아무런 능력이 없어서 내부에 메서드를 구현하지 않고 pass만 적어 주었습니다.



```python
>>> class LuckyChild(Parent):
        pass

```



Parent 클래스로부터 상속받은 LuckyChild 클래스에 대한 인스턴스를 생성한 후 노래를 시켜보겠습니다. 중요한 점은 현재 LuckyChild 클래스에는 어떤 메서드도 존재하지 않는다는 것입니다. 다음 코드를 보면 역시나 부모 클래스로부터 상속받아서 그런지 자신은 메서드를 포함하고 있지 않지만 바로 노래를 부를 수 있군요.



```python
>>> child1 = LuckyChild()
>>> child1.can_sing()
Sing a song
```



이번에는 부모로부터 어떤 능력이나 재산도 상속받지 못한 운이 좋지 않은 자식 클래스(UnLuckyChild)를 만들어 보겠습니다. 인간 세상으로 치면 평범한 서민 클래스라고 볼 수 있겠습니다.



```python
>>> class UnLuckyChild:
        pass


```



운이 좋지 않은 UnLuckyChild 클래스에 대한 인스턴스를 생성한 후 노래를 시켜봅시다. 역시나 상속도 받지 못했고 자신도 아무런 메서드가 없으므로 노래를 부를 수 없습니다. 



```python
>>> child2 = UnLuckyChild()
>>> child2.can_sing()
Traceback (most recent call last):
  File "<pyshell#53>", line 1, in <module>
    child2.can_sing()
AttributeError: 'UnLuckyChild' object has no attribute 'can_sing'
```



인간 세계에서는 상속을 받으면 좋겠구나, 라고 생각되겠지만 프로그래밍할 때 왜 상속을 해야 하는지 여전히 이해되지 않는 분도 계실 겁니다. 객체지향 프로그래밍에서는 어떤 클래스를 상속하면 부모 클래스의 모든 것을 내 것처럼 사용할 수 있고, 자신의 클래스에 메서드를 더 구현한다면 ‘플러스알파’가 되는 것입니다. 즉, 부모 클래스의 능력을 밑바탕으로 깔고 거기서부터 한 번 더 업그레이드되는 것입니다.

그럼 이번에는 노래도 잘 부르고 춤도 잘 추는 운이 좋은 자식 클래스2(LuckyChild2)를 정의해 보겠습니다.



```python
>>> class LuckyChild2(Parent):
        def can_dance(self):
                print("Shuffle Dance")
```



LuckyChild2 클래스에 대한 인스턴스를 생성한 후 노래와 춤을 시켜봅시다. LuckyChild2 클래스는 부모로부터 노래 부르는 능력을 상속받았고 자기 자신이 춤추는 능력을 갖추고 있어 노래도 부르고 춤 도출수있게됐습니다.



```python
>>> child2 = LuckyChild2()
>>> child2.can_sing()
Sing a song
>>> child2.can_dance()
Shuffle Dance
```



물론 굳이 상속이라는 기능을 사용하지 않고도 부모 클래스에 구현된 메서드를 그대로 복사해서 새로 정의할 클래스에 코드를 붙여넣는 식으로 사용할 수도 있습니다. 단, 이렇게 하면 같은 기능을 하는 코드가 중복되기 때문에 코드를 관리하기가 어렵고 복사 및 붙여넣기를 해야 하므로 불편합니다. 이에 반해 클래스의 상속이라는 기능을 이용하면 최소한의 코드로도 부모 클래스에 구현된 메서드를 손쉽게 바로 이용할 수 있습니다.



