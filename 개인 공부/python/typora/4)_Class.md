# 20190206

## 클래스(Class)

### 6) self 이해하기



앞에서 클래스 내에 정의된 함수를 메서드라고 부른다고 했습니다. 그리고 메서드의 첫 번째 인자는 항상 self여야 한다고 했습니다. 하지만 메서드의 첫 번째 인자가 항상 self여야 한다는 것은 사실 틀린 말입니다. 이번 절에서는 파이썬 클래스에서 self의 정체를 확실히 이해해 봅시다.

먼저 다음과 같이 두 개의 메서드가 정의된 Foo 클래스를 만들어 봅시다. 여기서 눈여겨봐야 할 점은 func1() 메서드의 첫 번째 인자가 self가 아님에도 클래스를 정의할 때 에러가 발생하지 않는다는 점입니다.

```python
>>> class Foo:
        def func1():
                print("function 1")
        def func2(self):
                print("function 2")

```



일단 클래스를 정의했으니 해당 클래스에 대한 인스턴스를 생성해보겠습니다. 그리고 생성된 인스턴스를 통해 인스턴스 메서드를 호출해보겠습니다. Foo 클래스의 func2 메서드는 메서드의 인자가 self뿐이므로 실제 메서드를 호출할 때는 인자를 전달할 필요가 없습니다.



```python
>>> f = Foo()
>>> f.func2()
function 2
```



위 코드에서 메서드를 호출한 결과를 보면 화면에 정상적으로 'function 2'가 출력된 것을 볼 수 있습니다. 참고로 func2 메서드의 첫 번째 인자는 self지만 호출할 때는 아무것도 전달하지 않는 이유는 첫 번째 인자인 self에 대한 값은 파이썬이 자동으로 넘겨주기 때문입니다.

그렇다면 func1 메서드처럼 메서드를 정의할 때부터 아무 인자도 없는 경우에는 어떻게 될까요? 다음과 같이 인스턴스를 통해 func1()을 호출해보면 오류가 발생합니다. 오류 메시지를 살펴보면 “func1()은 인자가 없지만 하나를 받았다”라는 것을 볼 수 있습니다. 이는 앞서 설명한 것처럼 파이썬 메서드의 첫 번째 인자로 항상 인스턴스가 전달되기 때문에 발생하는 문제입니다.



```python
>>> f.func1()
Traceback (most recent call last):
  File "<pyshell#25>", line 1, in <module>
    f.func1()
TypeError: func1() takes 0 positional arguments but 1 was given
```



이번에는 self의 정체를 좀 더 확실히 밝혀보기 위해 파이썬 내장 함수인 id를 이용해 인스턴스가 메모리에 할당된 주솟값을 확인해보겠습니다. 다음 코드처럼 Foo 클래스를 새로 정의합니다. func2 메서드가 호출될 때 메서드의 인자로 전달되는 self의 id 값을 화면에 출력하는 기능이 추가됐습니다.



```python
>>> class Foo:
        def func1():
                print("function 1")

        def func2(self):
                print(id(self))
                print("function 2")

```



Foo 클래스를 새롭게 정의했으므로 인스턴스를 다시 만든 후 id() 내장함수를 이용해 인스턴스가 할당된 메모리 주소를 확인해 봅시다.



```python
>>> f = Foo()
>>> id(f)
43219856
```



생성된 인스턴스가 메모리의 43219856번지에 있음을 확인할 수 있습니다. 참고로 이 값은 해당 코드의 실행 환경에 영향을 받게 되므로 여러분이 직접 실행했을 때 이 값과 다른 값이 나올 수 있습니다.

위 코드에서 f와 생성된 인스턴스의 관계를 그림으로 나타내면 그림 6.8과 같습니다. Foo 클래스에 대한 인스턴스는 메모리의 43219856번지부터 할당돼 있고 변수 f는 인스턴스의 주솟값을 담고 있습니다. 일단 인스턴스가 할당된 메모리 주솟값을 기억해두기 바랍니다. 곧 놀라운 광경을 목격할 수 있을 것입 니다.



![img](https://wikidocs.net/images/page/1742/6.08.png)

​								**그림 6.8 인스턴스의 메모리 주소 확인**



이번에는 인스턴스 f를 이용해 func2 메서드를 호출해보기 바랍니다. 다음 코드를 살펴보면 func2 메서드를 호출할 때 아무런 값도 전달하지 않았습니다.



```python
>>> f.func2()
43219856
function 2
```



실행 결과를 살펴보면 43219856이라는 값이 출력되는 것을 확인할 수 있습니다. Foo 클래스를 정의할 때 id(self)를 출력하게 했는데 id(self)의 값이 바로 43219856인 것입니다. 이 값은 그림 6.8에서 볼 수 있듯이 f라는 변수가 바인딩하고 있는 인스턴스의 주솟값과 동일합니다. 즉, 클래스 내에 정의된 self는 클래스 인스턴스임을 알 수 있습니다.

아직 이 부분이 잘 이해되지 않는다면 객체를 하나 더 만들어보겠습니다. 새로 생성한 객체는f2가 가리키고 있는데, id를 통해 확인해보니 주소가 47789232입니다. f2를 통해 func2 메서드를 호출해보면 47789232가 출력됐습니다. 이 값은 바로 f2가 가리키고 있는 객체를 의미합니다.



```python
>>> f2 = Foo()
>>> id(f2)
47789232
>>> f2.func2()
47789232
function 2
```



파이썬의 클래스는 그 자체가 하나의 네임스페이스이기 때문에 인스턴스 생성과 상관없이 클래스 내의 메서드를 직접 호출할 수 있습니다(네임스페이스는 다음 절에서 설명합니다).



```python
>>> Foo.func1()
function 1
```



위 코드는 func1 메서드를 호출했지만 앞서 인스턴스를 통해 메서드를 호출했던 것과는 달리 오류가 발생하지 않는 것을 확인할 수 있습니다. 왜냐하면 인스턴스.메서드() 형태로 호출한 것과 달리 이번에는 클래스명.메서드() 형태로 호출했기 때문입니다. 그렇다면 func2()에 대해서도 클래스 이름을 통해 호출해 봅시다. 그림 6.9와 같이 클래스 이름을 통해 func2() 메서드를 호출하려고 하면 self 위치에 인자를 전달해야 한다고 파이썬 인터프리터가 알려줍니다.



![img](https://wikidocs.net/images/page/1742/6.09.png)

​								**그림 6.9 클래스 이름을 이용한 메서드 호출**



self 위치에 인자를 전달하지 않고 메서드를 호출하면 그림 6.10과 같이 오류가 발생합니다. 오류 메시지를 확인하면 func2()를 호출할 때 인자를 하나 빠트렸음을 알 수 있습니다. 즉, 인자를 하나 전달해야 하는데 전달하지 않아서 오류가 발생한 것입니다.



![img](https://wikidocs.net/images/page/1742/6.10.png)

​								**그림 6.10 클래스 이름을 이용한 메서드 호출 에러**

그럼 도대체 어떤 값을 전달하면 되는 걸까요? 앞에서 메서드의 self로 전달되는 것은 인스턴스 자체라고 설명했습니다. 따라서 클래스에 대한 인스턴스를 생성한 후 해당 인스턴스를 전달하면 됩니다. 다음과 같이 새로운 객체를 만들고 이를 f3이 가리키게 합니다. id(f3) 구문 호출을 통해 f3이 가리키는 객체의 주소가 47789136임을 확인할 수 있습니다.



```python
>>> f3 = Foo()
>>> id(f3)
47789136
```



다시 한 번 클래스 이름인 Foo를 이용해 func2 메서드를 호출해보겠습니다. 앞서 func2 메서드는 인자를 하나 필요로 하며, 해당 인자는 인스턴스여야 한다고 말씀드렸습니다. 현재 f3은 새로 생성한 인스턴스를 바인딩하고 있으므로 func2 메서드의 인자로 f3을 전달하면 됩니다.



```python
>>> Foo.func2(f3)
47789136
func2
```



그렇다면 인스턴스를 통해 func2를 호출하는 것과 클래스 이름을 통해 func2를 호출하는 것은 어떤 차이가 있을까요? 결론부터 말씀드리면 둘 사이에는 아무런 차이가 없습니다. 다만 ‘인스턴스.메서드()’냐 ‘클래스.메서드(인스턴스)’냐라는 차이가 있을 뿐입니다. 보통은 ‘인스턴스.메서드()’와 같은 방식을 주로 사용합니다.



```python
>>> f3.func2()
47789136
func2
```



----



### 7) 클래스 네임스페이스



클래스와 인스턴스의 차이를 정확히 이해하는 것은 매우 중요합니다. 이를 위해서는 먼저 네임스페이스라는 개념을 알아야 합니다. 네임스페이스라는 것은 변수가 객체를 바인딩할 때 그 둘 사이의 관계를 저장하고 있는 공간을 의미합니다. 예를 들어,'a = 2'라고 했을 때a라는 변수가2라는 객체가 저장된 주소를 가지고 있는데 그러한 연결 관계가 저장된 공간이 바로 네임스페이스입니다.

파이썬의 클래스는 새로운 타입(객체)을 정의하기 위해 사용되며, 모듈과 마찬가지로 하나의 네임스페이스를 가집니다. 먼저 Stock 클래스를 정의해 봅시다.



```python
>>> class Stock:
        market = "kospi"

```



파이썬 IDLE에서 dir 내장 함수를 호출해보면 리스트로 된 반환값을 확인할 수 있습니다. 여기서 두 개의 언더바로 시작하는 것은 파이썬에서 이미 사용 중인 특별한 것들입니다. 이를 제외하고 보면 조금 전에 정의했던 Stock 클래스의 이름이 포함된 것을 확인할 수 있습니다.



```python
>>> dir()
['Stock', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
```



dir 내장함수의 결괏값에 Stock 클래스가 들어있기 때문에 앞으로는 프롬프트에 Stock을 입력해도 오류가 발생하지 않습니다. 그러나 Stock1이라는 이름은 존재하지 않기 때문에 입력하면 오류가 발생 합니다.



```python
>>> Stock
<class '__main__.Stock'>
>>> Stock1
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    Stock1
NameError: name 'Stock1' is not defined
```



파이썬에서는 클래스가 정의되면 그림 6.11과 같이 하나의 독립적인 네임스페이스가 생성됩니다. 그리고 클래스 내에 정의된 변수나 메서드는 해당 네임스페이스 안에 파이썬 딕셔너리 타입으로 저장됩니다. Stock 클래스는 그림 6.11과 같이 Stock이라는 네임스페이스 안에 'market':'kospi'라는 값을 가진 딕셔너리를 포함합니다.



![img](https://wikidocs.net/images/page/1743/6.11.png)

​								**그림 6.11 파이썬 클래스 네임스페이스**



Stock 클래스의 네임스페이스를 파이썬 코드로 확인하려면 클래스의 `__dict__` 속성을 확인하면 됩니다. 딕셔너리 타입에 'market':'kospi'라는 키와 값 쌍이 존재하는 것을 확인할 수 있습니다.



```python
>>> Stock.__dict__
mappingproxy({'market': 'kospi', '__module__': '__main__', '__dict__': <attribute '__dict__' of 'Stock' objects>, '__doc__': None, '__weakref__': <attribute '__weakref__' of 'Stock' objects>})
```



클래스가 독립적인 네임스페이스를 가지고 클래스 내의 변수나 메서드를 네임스페이스에 저장하고 있으므로 다음과 같이 클래스 내의 변수에 접근할 수 있는 것입니다.



```python
>>> Stock.market
'kospi'
```



이번에는 인스턴스를 생성해보겠습니다. 다음과 같이 서로 다른 두 개의 인스턴스를 생성해보기 바랍니다. 생성된 인스턴스에 대한 id 값을 확인해보면 두 인스턴스가 서로 다른 메모리에 위치하는 것을 확인할 수 있습니다.



```python
>>> s1 = Stock()
>>> s2 = Stock()
>>> id(s1)
50572464
>>> id(s2)
50348240
```



파이썬은 인스턴스를 생성하면 인스턴스별로 별도의 네임스페이스를 유지합니다. 즉, 위의 코드를 그림으로 표현하면 그림 6.12와 같습니다.



![img](https://wikidocs.net/images/page/1743/6.12.png)

​								**그림 6.12 클래스와 인스턴스의 네임스페이스**



먼저 생성된 s1, s2 인스턴스가 네임스페이스에 있는지 코드를 통해 확인해 봅시다. dir 내장함수의 반환값을 확인하면 s1, s2가 Stock과 마찬가지로 존재하는 것을 확인할 수 있습니다.



```python
>>> dir()
['Stock', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 's1', 's2']
```



생성된 s1, s2 인스턴스 각각에 대한 네임스페이스도 확인해봅시다. 클래스 또는 인스턴스에 대한 네임스페이스를 확인하려면 `__dict__` 속성을 확인하면 됩니다.



```python
>>> s1.__dict__
{}
>>> s2.__dict__
{}
```



위 코드를 보면 s1과 s2 인스턴스의 네임스페이스는 현재 비어 있음을 확인할 수 있습니다. s1 인스턴스에 market이라는 변수를 추가해 봅시다. 그런 다음 다시 `__dict__` 속성을 확인해보면 'market':'kosdaq'이라는 키:값 쌍이 추가된 것을 볼 수 있습니다.



```python
>>> s1.market = 'kosdaq'
>>> s1.__dict__
{'market': 'kosdaq'}
```



그러나 여전히 s2 인스턴스의 네임스페이스는 비어 있는 상태입니다. 현재 Stock 클래스와 s1, s2 인스턴스의 네임스페이스를 그림으로 나타내면 그림 6.13과 같습니다.



```python
>>> s2.__dict__
{}
```



![img](https://wikidocs.net/images/page/1743/s6.13.png)



​								**그림 6.13 클래스와 인스턴스의 네임스페이스 상태**



현재 Stock 클래스로부터 s1, s2라는 두 개의 인스턴스를 생성했습니다. s1 인스턴스는 market이라는 변수를 가지고 있지만 s2의 네임스페이스에는 변수나 메서드가 존재하지 않습니다. 만약 s1.market, s2.market과 같이 인스턴스를 통해 market이라는 값에 접근하면 어떻게 될까요?



```python
>>> s1.market
'kosdaq'
>>> s2.market
'kospi'
```



위 코드를 참조하면 s1.market의 값은 'kosdaq'입니다. 이것은 그림 6.13과 같이 s1 인스턴스의 네임스페이스에 'market':'kosdaq'이라는 키:값 쌍이 존재하기 때문에 가능합니다. 그런데 s2 인스턴스의 반환값을 살펴보면 조금 이상합니다. 왜냐하면 현재 s2의 네임스페이스(딕셔너리)에는 아무런 값도 존재하지 않기 때문입니다. s2의 네임스페이스에는 변수나 메서드가 존재하지 않지만 s2.market의 값으로 'kospi'라는 문자열이 반환되는 이유는 그림 6.14와 같이 동작하기 때문입니다.



![img](https://wikidocs.net/images/page/1743/s6.14.png)

​							**그림 6.14 클래스 및 인스턴스의 네임스페이스 참조 방식**



s2 인스턴스를 통해 변수에 접근하면 파이썬은 먼저 s2 인스턴스의 네임스페이스에서 해당 변수가 존재하는지 찾습니다. s2의 네임스페이스에 해당 변수가 존재하지 않으면 s2 인스턴스의 클래스의 네임스페이스로 가서 다시 변수를 찾게 됩니다. 즉, s2.market이라는 문장이 실행되면 Stock 클래스의 네임스페이스에 있는 'market':'kospi' 키:값 쌍에서 'kospi'라는 문자열을 출력하게 됩니다.

이번에는 인스턴스의 네임스페이스에도 없고 클래스의 네임스페이스에도 없는 변수에 접근해 봅시다. 이 경우 volume이라는 값이 s2 인스턴스의 네임스페이스에 없으므로 Stock 클래스에서 찾게 되는데, Stock 클래스의 네임스페이스에도 volume이라는 값이 없으므로 오류가 발생합니다.



```python
>>> s2.volume
Traceback (most recent call last):
  File "<pyshell#22>", line 1, in <module>
    s2.volume
AttributeError: 'Stock' object has no attribute 'volume'
```