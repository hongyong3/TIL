import sys
sys.stdin = open("D4_11316_input.txt", "r")

'''
6, 8, 3(3번째), 7, 2, 3(6번째), 7, 2, 3, 7, 2의 경우를 보면,

6, 8, 3, 7, 2가 나오고 다시 앞에 나왔던 숫자들 중 같은 수인 3이 나옵니다.
p, q, m이 고정값이므로 주어진 식대로 이해한 바와 같이 뒤에는 반복되어 나옵니다.
주기가 찾아졌으니 그 뒤는 더 이상 연산할 필요없고,

반복된 숫자가 나온 턴에서 그 숫자가 나왔던 턴을 저장해 놓는 배열의 값을 빼면 주기가 됩니다.
6번째에 나온 3이 3번째에 나왔으니 6 - 3 = 3이 주기가 됩니다.

제가 푼 방식대로라면 m(1~1,000,000)으로 나눈 나머지는 최대 1,000,000까지 나오니 배열을 0으로 초기화해 선언해 두고,
처음 a0 = s가 주어질때 arr[s] = 1(s는 1번째 나머지 라고 생각),

while문 시작-------------------------------------------------------------------------------------------------------------
s로 다음 a1을 구합니다.(주어진 식대로)
a1을 구했으면 그 숫자가 앞서 나왔던 숫자인지 체크해보기 위해서 배열을 봅니다.
이때, arr[a1] == 0이면 a1이라는 숫자는 앞에 나왔던 숫자가 아닌 새로운 숫자이므로 이번 턴(i,번째)를 저장합니다.(arr[a1] = i)
arr[a1] != 0이면 a1이라는 숫자는 0이 아닌 어떤 번째에 있었던 숫자이므로 
이번 턴(i)에서 arr[a1](a1이 몇 번째에 있었는지에 대한 번째가 저장되어 있음)을 뺀 것이 주기가(정답이) 되고 while문을 나오면 됩니다.
while문 끝---------------------------------------------------------------------------------------------------------------

케이스가 여러개니 케이스마다 arr[] 초기화 해주시고요. 

저는 이런식으로 통과했는데 사실상 제가 설명한 거랑 이해하신게 같은듯 합니다. 다 푸셨는데 실수하셨을거 같은데 참고하세요~
'''

# ...?
# T = int(input())
# for test_case in range(T):
#     s, p, q, m = map(int, input().split())
#
#     A, chk = [s], True
#     num, idx = s, 1
#     while chk:
#         num = (p * num + q) % m
#
#         if num in A:
#             chk = False
#             break
#         A.append(num)
#         idx += 1
#     for j in range(idx):
#         if num == A[j]:
#             idx -= j
#             break
#     print("#{} {}".format(test_case + 1, idx))

T = int(input())
for test_case in range(T):
    s, p, q, m = map(int, input().split())
    visited, chk = [0] * m, [0] * m

    a = s
    visited[a] = 1
    chk[0] = a

    for i in range(1, m + 1):
        total = (p * a + q) % m
        a = total
        if not visited[a]:
            visited[a] = 1
            chk[i] = a
        else:
            print("#{} {}".format(test_case + 1, i - chk.index(a)))
            break